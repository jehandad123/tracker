<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Hands-Free Task Manager</title>
  <script src="chrono.min.js"></script>
  <style>
    body {
      font-family: sans-serif;
      padding: 16px;
      margin: auto;
      font-size: 18px;
      line-height: 1.6;
      background-color: #fff;
      max-width: 600px;
    }

    button {
      padding: 16px 24px;
      font-size: 22px;
      margin-top: 12px;
      border-radius: 8px;
      cursor: pointer;
      min-height: 44px;
      box-sizing: border-box;
    }

    input[type="text"], input[type="number"], textarea {
      width: 100%;
      padding: 16px;
      font-size: 20px;
      border-radius: 8px;
      margin-top: 10px;
      box-sizing: border-box;
    }

    h2, h3 {
      font-size: 24px;
      margin-top: 24px;
    }
    
    #transcript, #gptAnswer {
      margin-top: 20px;
      padding: 16px;
      border-radius: 6px;
      min-height: 30px;
      background: #e0f7fa;
      font-size: 18px;
    }

    .category ul {
      padding-left: 0;
      list-style: none;
    }

    .task-row {
      background: #e0f7fa;
      padding: 16px;
      border-radius: 6px;
      margin-bottom: 12px;
      font-size: 20px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    .task-controls {
      margin-top: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .task-controls button {
      flex: 1 1 auto;
      padding: 8px 8px !important;
      font-size: 20px;
      min-width: 44px;
    }

    .dropdown-content button {
      font-size: 18px;
      padding: 10px;
    }

    .edit-input {
      font-size: 20px;
      padding: 12px;
    }

    .date-badge {
      font-size: 16px;
      padding: 4px 8px;
      margin-left: 10px;
      border-radius: 4px;
      background-color: #e0e0e0;
    }

.category-nav button {
  background-color: #e0f2f1;
  margin-right: 10px;
  margin-top: 10px;
}
    #backToTop {
  position: fixed;
  bottom: 20px;
  left: 10px;
  padding: 10px 14px;
  font-size: 16px;
  background-color: #d0d0d0;
  border-radius: 6px;
  cursor: pointer;
  display: none;
  z-index: 999;
}
// new yellow buttons sizing
    .control-buttons {
  display: flex;
  gap: 8px; /* space between buttons */
  flex-wrap: wrap;
  margin-top: 12px;
}

.control-buttons button {
  font-size: 14px;
  padding: 8px 12px;
  flex: 1;
  white-space: nowrap;
}

.control-buttons button {
  transition: opacity 0.3s ease;
}
    
#stopBtn,
#interruptTTSBtn,
#muteMicBtn {
  display: none;
}
  </style>
</head>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Hands-Free Task Manager</title>
  <script src="chrono.min.js"></script>
  <style>
body {
  font-family: sans-serif;
  padding: 16px;
  max-width: 100%;
  margin: auto;
  font-size: 18px;         /* ‚¨ÖÔ∏è Larger default font */
  line-height: 1.6;        /* ‚¨ÖÔ∏è Better readability */
  background-color: #fff;  /* optional: white background */
}

button {
  padding: 14px 24px;       /* Bigger padding */
  font-size: 20px;           /* Larger text */
  margin-top: 12px;
  border-radius: 6px;        /* Rounded corners for better look */
  cursor: pointer;
  min-height: 44px;          /* Recommended mobile tap target height üëç */
  line-height: 1.4;
  width: auto;
}

    
    
    #speakBtn.recording, #handsFreeBtn.recording { background: #d32f2f; color: #fff; }
    #stopBtn, #interruptTTSBtn, #muteMicBtn { margin-left: 10px; }
    #transcript { margin-top: 20px; border: 1px solid #ccc; padding: 10px; min-height: 30px; white-space: pre-wrap; }
    #gptAnswer { margin-top: 18px; padding: 10px; background: #f3f3f3; border-radius: 6px; min-height: 30px; }
    #gptLoading { color: #d32f2f; display: none; }
    .category { margin-top: 20px; }
.category h3 {
  font-size: 22px;
  font-weight: bold;
}
    ul { list-style-type: disc; padding-left: 20px; }
input[type=text] {
  width: 100%;
  padding: 14px;
  font-size: 20px;
  border-radius: 6px;
}
    .api-inputs { margin-bottom: 16px; }
    .api-inputs label { display: block; margin-top: 8px; }
    .task-input { margin-top: 20px; }
.task-row {
  display: flex;
  flex-direction: column; /* üÜï Put text above controls */
  align-items: flex-start;
  margin-bottom: 12px;
  padding: 12px;
  background: #e0f7fa;
  border-radius: 6px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
}    

    .task-text {
  font-size: 15px !important;
  font-weight: normal !important;
  line-height: 1.4;
}

  .task-controls {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
}

    .task-controls button {
  font-size: 20px;
  padding: 12px 16px;
  min-width: 44px;
  min-height: 44px;
  flex: 1 1 auto;
}
    .dropdown { position: relative; display: inline-block; }
    .dropdown-content {
      display: none;
      position: absolute;
      right: 0;
      background-color: #f9f9f9;
      min-width: 100px;
      box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
      z-index: 1;
      border-radius: 4px;
      overflow: hidden;
    }
    .dropdown-content button {
      color: black;
      padding: 8px 12px;
      text-align: left;
      text-decoration: none;
      display: block;
      border: none;
      background: none;
      width: 100%;
      font-size: 14px;
      cursor: pointer;
    }
    .dropdown-content button:hover {
      background-color: #f1f1f1;
    }
    .dropdown.show .dropdown-content {
      display: block;
    }
    .edit-input {
      width: 80%;
      padding: 3px 6px;
      font-size: 15px;
    }
    .hidden { display: none !important; }
    .date-badge {
      background: #e0e0e0;
      color: #333;
      border-radius: 4px;
      padding: 2px 7px;
      font-size: 12px;
      margin-left: 8px;
    }
    #showAllBtn { margin-top: 10px; margin-bottom: 10px; }
    #exportTasksBtn { margin-top: 16px; }
    #backupArea { margin-top: 8px; font-size: 13px; }
    #interruptTTSBtn, #muteMicBtn { background: #fbc02d; color: #222; }
    #muteMicBtn.muted { background: #bdbdbd; color: #666; }

  /* üîª Add this to the bottom of your <style> block */
@media (max-width: 600px) {
  body {
    font-size: 18px;
    padding: 14px;
  }

  .task-text {
    font-size: 24px;
  }

  .task-controls button {
    font-size: 20px;
    padding: 12px 16px;
    min-height: 48px; /* big enough for mobile tap */
  }

  input[type="text"] {
    font-size: 20px;
    padding: 14px;
    width: 100%;
  }

  button {
    font-size: 20px;
    padding: 14px 20px;
  }

  .category h3 {
    font-size: 22px;
    margin-top: 24px;
  }

  #gptAnswer, #transcript {
    font-size: 20px;
    line-height: 1.6;
  }
}
  
  </style>
</head>
<body>
  <h2 style="text-align:center; margin-top: 10px;">JD's Virtual Voice Assistant </h2>
  <p style="text-align:center; font-style: italic; font-size: 0.95em; margin-top: -8px; color: #555;">Talk. Track. Triumph!</p>
  <button id="speakBtn">üéôÔ∏è Speak</button>
  <button id="handsFreeBtn">ü§ñ Dialog</button>
 <div class="control-buttons">
  <button id="stopBtn">üõë Stop</button>
  <button id="interruptTTSBtn">üîá Interrupt</button>
  <button id="muteMicBtn">üé§ Mute</button>
</div>
  <span id="gptLoading">Thinking...</span>
<div id="transcript" style="color: #888;">Your Speech will show here...</div>
<div id="gptAnswer" style="color: #888;">Virtual Assistant's response....</div>
  <div class="category-nav">
  <button onclick="scrollToCategory('Home')">üè† Home</button>
  <button onclick="scrollToCategory('Shop')">üõí Shop</button>
  <button onclick="scrollToCategory('Work')">üíº Work</button>
  <button onclick="scrollToCategory('Manager')">üëî Manager</button>
</div>
 <div class="task-input">
    <input type="text" id="manualInput" placeholder="Enter task and category at end (e.g. Buy milk Manager)" />
    <button id="addManualBtn">Add Task Manually</button>
 </div>
  <button id="showAllBtn" style="display:none;">Show All Tasks</button>
  <div id="categories">
    <div class="category" id="Home">
      <h3>Home</h3>
      <ul></ul>
    </div>
    <div class="category" id="Shop">
      <h3>Shop</h3>
      <ul></ul>
    </div>
    <div class="category" id="Work">
      <h3>Work</h3>
      <ul></ul>
    </div>
    <div class="category" id="Manager">
      <h3>Manager</h3>
      <ul></ul>
    </div>
  </div>
     </div>
  <!-- üéöÔ∏è Silence Threshold / Duration Controls -->
<h3>üéöÔ∏è Settings</h3>
  <div style="margin-top: 16px;">
  <label>
    Silence Threshold:
    <input type="number" id="silenceThresholdInput" min="0.001" max="0.2" step="0.001" value="0.05" />
  </label>
  <label style="margin-left: 10px;">
    Silence Duration (ms):
    <input type="number" id="silenceDurationInput" min="500" max="10000" step="100" value="3000" />
  </label>
</div>
  <div style="margin-top:10px;">
  <label>
    End of Week =
    <select id="eowPolicy">
      <option value="friday">Friday</option>
      <option value="saturday">Saturday</option>
      <option value="sunday">Sunday</option>
    </select>
  </label>
</div>
<script>
  (function(){
    const sel = document.getElementById('eowPolicy');
    if (sel) {
      sel.value = localStorage.getItem('EOW_POLICY') || 'sunday';
      sel.onchange = () => localStorage.setItem('EOW_POLICY', sel.value);
    }
  })();
</script>

  <button id="exportTasksBtn">Export Tasks (Backup)</button>
  <button id="importTasksBtn">Import Tasks</button>
  <textarea id="backupArea" style="width:100%;height:80px;" placeholder="Backup JSON will appear here. Paste here to restore."></textarea>
  <!-- BEEP AUDIO ELEMENT REMOVED -->

  <script>
  function scrollToCategory(id) {
    const el = document.getElementById(id);
    if (el) el.scrollIntoView({ behavior: 'smooth' });
  }
</script>
<button id="backToTop" onclick="scrollToTop()">üîù Back to Top</button>
  <script>
  function scrollToTop() {
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }

  window.addEventListener('scroll', () => {
    const btn = document.getElementById('backToTop');
    btn.style.display = window.scrollY > 300 ? 'block' : 'none';
  });
</script>
 <div class="api-inputs">
    <label>
      OpenAI API Key:
      <input type="text" id="openaiKey" placeholder="Paste your OpenAI API Key" autocomplete="off" />
    </label>
    <label>
      AssemblyAI API Key:
      <input type="text" id="assemblyKey" placeholder="Paste your AssemblyAI API Key" autocomplete="off" />
    </label>
    <button id="saveKeysBtn">Save API Keys</button>
    <span id="apiKeySaved" style="color: green; display: none;">‚úîÔ∏è Saved!</span>
  </div>
   <script>


function correctTranscriptNames(text) {
  const corrections = [
    { wrong: ["shravan", "shivan"], correct: "Sravan" },
    { wrong: ["arsh", "arch", "arish", "arush"], correct: "Arsshh" },
    { wrong: ["courtney"], correct: "Cortney" },
    { wrong: ["brendan"], correct: "Brandon" },
    { wrong: ["migel"], correct: "Miguel" },
    { wrong: ["shazip", "shazeb", "shahzeh"], correct: "Shahzeb" },
    { wrong: ["mareen", "marine", "meh reen", "mahreen", "mehren"], correct: "Mehreen" },
    { wrong: ["humza"], correct: "Hamza" },
    { wrong: ["shah rose", "cheros", "shadows", "sheroz", "cheroz", "chehreau's", "sharrow's"], correct: "Shahroz" },
    { wrong: ["maywish", "meh wish"], correct: "Mehwish" },
    { wrong: ["ametraj", "amatraj"], correct: "Amitraj" }

  ];

  let corrected = text;

  corrections.forEach(entry => {
    entry.wrong.forEach(w => {
      const regex = new RegExp("\\b" + w.replace(/ /g, "\\s+") + "\\b", "gi");
      corrected = corrected.replace(regex, entry.correct);
    });
  });

  return corrected;
}



    // ====== CONFIG ======
    const SILENCE_THRESHOLD = Number(document.getElementById("silenceThresholdInput").value) || 0.05;
const SILENCE_DURATION = Number(document.getElementById("silenceDurationInput").value) || 3000;
    const MIC_THRESHOLD = 0.03; // Adjust for noise sensitivity
const REQUIRED_ACTIVE_FRAMES = 5; // ‚úÖ How many frames need to be "loud" to trigger speaking

    // ====== NEW BEEP FUNCTION (Web Audio API) ======
    function playBeep(frequency = 1500, duration = 120) {
      try {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = ctx.createOscillator();
        const gain = ctx.createGain();
        oscillator.type = 'sine';
        oscillator.frequency.value = frequency;
        oscillator.connect(gain);
        gain.connect(ctx.destination);
        oscillator.start();
        gain.gain.setValueAtTime(1, ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0, ctx.currentTime + duration / 1000);
        oscillator.stop(ctx.currentTime + duration / 1000);
        oscillator.onended = () => ctx.close();
      } catch (e) {}
    }

    // ====== DOM ELEMENTS ======
    const openaiKeyInput = document.getElementById("openaiKey");
    const assemblyKeyInput = document.getElementById("assemblyKey");
    const saveKeysBtn = document.getElementById("saveKeysBtn");
    const apiKeySaved = document.getElementById("apiKeySaved");
    const speakBtn = document.getElementById("speakBtn");
    const handsFreeBtn = document.getElementById("handsFreeBtn");
    const stopBtn = document.getElementById("stopBtn");
    const interruptTTSBtn = document.getElementById("interruptTTSBtn");
    const muteMicBtn = document.getElementById("muteMicBtn");
    const transcriptDiv = document.getElementById("transcript");
    const manualInput = document.getElementById("manualInput");
    const addManualBtn = document.getElementById("addManualBtn");
    const showAllBtn = document.getElementById("showAllBtn");
    const gptAnswer = document.getElementById("gptAnswer");
    const gptLoading = document.getElementById("gptLoading");
    const exportTasksBtn = document.getElementById("exportTasksBtn");
    const importTasksBtn = document.getElementById("importTasksBtn");
    const backupArea = document.getElementById("backupArea");

    const categories = ["Home", "Shop", "Work", "Manager"];

    // ==== TTS Unlock Logic ====
    let ttsUnlocked = false;
    function unlockTTS() {
      return new Promise(resolve => {
        if (ttsUnlocked) return resolve();
        let utter = new SpeechSynthesisUtterance(" ");
        utter.onend = () => { ttsUnlocked = true; resolve(); };
        utter.onerror = () => { ttsUnlocked = true; resolve(); };
        window.speechSynthesis.speak(utter);
      });
    }

    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

    function stripBeforeAddOrCreate(input) {
      let match = input.match(/\b(add|create)\b/i);
      if (match) {
        return input.slice(match.index).trim();
      }
      return input.trim();
    }

    function extractValidCategory(raw) {
      if (!raw) return null;
      let normalized = raw.toLowerCase();
      normalized = normalized.replace(/[\.\,\!\?\;\:]+/g, '');
      normalized = normalized.replace(/\b(category|list|task|under|the|a|an|in|to|for|on|of|as|at|with|by|from|into|onto|and|or|add|new|my)\b/g, '').trim();
      normalized = normalized.replace(/\s{2,}/g, ' ').trim();
      for (const cat of categories) {
        if (normalized === cat.toLowerCase()) return cat;
        if (normalized.includes(cat.toLowerCase())) return cat;
      }
      return null;
    }

    function preprocessInput(input) {
      return input.replace(/[\.\,\!\?\;\:]+/g, ' ').replace(/\s+/g, ' ').trim();
    }

    function extractTaskText(input, category) {
      if (!category) return input.trim();
      const regex = new RegExp(`\\b${category}\\b[\\.\\!\\?\\s]*$`, 'i');
      return input.replace(regex, '').trim();
    }
function formatDateLabel(d) {
  return d.toLocaleDateString(undefined, { year: "numeric", month: "short", day: "numeric" });
}

// ‚Äî‚Äî CONFIG: what is "end of the week"? ‚Äî‚Äî
// Options: "friday", "saturday", "sunday"
const EOW_POLICY = localStorage.getItem("EOW_POLICY") || "sunday";

function addDays(d, n) { const x = new Date(d); x.setDate(x.getDate()+n); return x; }
function startOfWeek(d) {
  const dd = new Date(d.getFullYear(), d.getMonth(), d.getDate());
  const day = dd.getDay(); // 0 Sun ... 6 Sat
  dd.setDate(dd.getDate() - day);
  dd.setHours(0,0,0,0);
  return dd;
}
function endOfThisWeek(policy = EOW_POLICY) {
  const s = startOfWeek(new Date());
  const idx = (policy === "friday") ? 5 : (policy === "saturday" ? 6 : 6);
  const e = addDays(s, idx);
  e.setHours(0,0,0,0);
  return e;
}
function endOfNextWeek(policy = EOW_POLICY) {
  const s = startOfWeek(addDays(new Date(), 7));
  const idx = (policy === "friday") ? 5 : (policy === "saturday" ? 6 : 6);
  const e = addDays(s, idx);
  e.setHours(0,0,0,0);
  return e;
}

// Quick yyyy-mm-dd key (ignore time zone/time part for equality)
function ymd(d) {
  return [d.getFullYear(), String(d.getMonth()+1).padStart(2,"0"), String(d.getDate()).padStart(2,"0")].join("-");
}

// Normalize any date phrase in the task text to an absolute label like "Aug 16, 2025"
// Also return an ISO date for structured matching later.
function normalizeTaskTextAndDate(rawText) {
  let text = (rawText || "").trim();

  // Special fuzzy phrases first
if (/\b(end of (the )?week|eow)\b/i.test(text) && !/\bnext\b/i.test(text)) {
  const dt = endOfThisWeek();
  dt.setHours(0,0,0,0);
  const iso = dt.toISOString();
  const label = formatDateLabel(dt);
  text = text.replace(/\b(end of (the )?week|eow)\b/ig, label).replace(/\s{2,}/g, " ").trim();
  return { cleanText: text, dateISO: iso };
}

if (/\b(end of next week|eonw)\b/i.test(text)) {
  const dt = endOfNextWeek();
  dt.setHours(0,0,0,0);
  const iso = dt.toISOString();
  const label = formatDateLabel(dt);
  text = text.replace(/\b(end of next week|eonw)\b/ig, label).replace(/\s{2,}/g, " ").trim();
  return { cleanText: text, dateISO: iso };
}

if (/\b(this weekend)\b/i.test(text)) {
  const end = endOfThisWeek();
  const dt = (EOW_POLICY === "friday") ? addDays(end, 1) : end; // Friday policy ‚Üí Saturday
  dt.setHours(0,0,0,0);
  const iso = dt.toISOString();
  const label = formatDateLabel(dt);
  text = text.replace(/\b(this weekend)\b/ig, label).replace(/\s{2,}/g, " ").trim();
  return { cleanText: text, dateISO: iso };
}

if (/\b(next weekend)\b/i.test(text)) {
  const endNext = endOfNextWeek();
  const dt = (EOW_POLICY === "friday") ? addDays(endNext, 1) : endNext;
  dt.setHours(0,0,0,0);
  const iso = dt.toISOString();
  const label = formatDateLabel(dt);
  text = text.replace(/\b(next weekend)\b/ig, label).replace(/\s{2,}/g, " ").trim();
  return { cleanText: text, dateISO: iso };
}

// Fallback to chrono for everything else (tomorrow, explicit dates, etc.)
const results = chrono.parse(text, new Date());
if (results && results.length > 0) {
  const r = results[0]; // first date mention
  const dt = r.start.date();
  dt.setHours(0,0,0,0);
  const iso = dt.toISOString();
  const before = text.slice(0, r.index);
  const after  = text.slice(r.index + r.text.length);
  const label  = formatDateLabel(dt);
  const cleaned = (before + label + after).replace(/\s{2,}/g, " ").trim();
  return { cleanText: cleaned, dateISO: iso };
}
return { cleanText: text, dateISO: null };
}

// Parse the user's question for a target date or range.
// Returns {type:"single", ymd:"YYYY-MM-DD"} or {type:"range", startYmd, endYmd} or null
// Parse the user's question for a target date or range.
// Returns {type:"single", ymd:"YYYY-MM-DD"} or {type:"range", startYmd, endYmd} or null
function resolveQueryDateOrRange(query) {
  let q = (query || "").toLowerCase();
// normalize phrasing like "month of august" ‚Üí "august"
  q = q.replace(
    /\bmonth\s+of\s+(jan(?:uary)?|feb(?:ruary)?|mar(?:ch)?|apr(?:il)?|may|jun(?:e)?|jul(?:y)?|aug(?:ust)?|sep(?:t|tember)?|oct(?:ober)?|nov(?:ember)?|dec(?:ember)?)\b/,
    "$1"
  );

  const today = new Date();
  const t0 = new Date(); t0.setHours(0,0,0,0);

  const add = (d,n)=>{ const x = new Date(d); x.setDate(x.getDate()+n); x.setHours(0,0,0,0); return x; };

  // ---------- NEW: generic "next N days/weeks" (digits OR words) ----------
  // Examples: "next 7 days", "in the next 10 days", "within next two weeks", "over the upcoming 3 weeks"
  const windowMatch = q.match(/\b(?:in|within|over)?\s*(?:the\s+)?(?:next|coming|upcoming)\s+([a-z\- ]+|\d{1,3})\s+(days?|weeks?)\b/);
  if (windowMatch) {
    let raw = windowMatch[1].trim();               // "10" or "ten" or "twenty-one"
    const unit = windowMatch[2].startsWith("week") ? "weeks" : "days";

    // Parse number from digits or words (supports 1..60 in words, incl. "twenty one")
    let n = Number(raw);
    if (!Number.isFinite(n)) {
      const wordMap = {
        one:1,two:2,three:3,four:4,five:5,six:6,seven:7,eight:8,nine:9,ten:10,
        eleven:11,twelve:12,thirteen:13,fourteen:14,fifteen:15,sixteen:16,seventeen:17,eighteen:18,nineteen:19,
        twenty:20,thirty:30,forty:40,fifty:50,sixty:60
      };
      raw = raw.replace(/-/g, " ");
      n = raw.split(/\s+/).reduce((sum, w) => {
        if (!w) return sum;
        if (!(w in wordMap)) return NaN;
        return sum + wordMap[w];
      }, 0);
    }

    if (Number.isFinite(n) && n > 0) {
      const days = (unit === "weeks") ? n * 7 : n;
      const start = new Date(t0);
      const end   = add(t0, days - 1);  // inclusive: today .. today+(N-1)
      return { type: "range", startYmd: ymd(start), endYmd: ymd(end) };
    }
    // fall through if unparseable
  }
  // ---------- END NEW ----------

  // Specific quick windows (still supported; the generic handler above also covers these)
  if (/\bnext\s+(two|2)\s+weeks\b/.test(q) || /\bnext\s+14\s+days\b/.test(q)) {
    const s = new Date(t0);
    const e = add(s, 13);
    return { type: "range", startYmd: ymd(s), endYmd: ymd(e) };
  }
  if (/\bnext\s+7\s+days\b/.test(q)) {
    const s = new Date(t0);
    const e = add(s, 6);
    return { type: "range", startYmd: ymd(s), endYmd: ymd(e) };
  }

  // Weeks
  if (/\b(this|current)\s+week\b/.test(q)) {
    const s = startOfWeek(today);
    const e = addDays(s, 6);
    return { type: "range", startYmd: ymd(s), endYmd: ymd(e) };
  }
  if (/\b(next|upcoming|coming)\s+week\b/.test(q)) {
    const s0 = startOfWeek(addDays(today, 7));
    const e0 = addDays(s0, 6);
    return { type: "range", startYmd: ymd(s0), endYmd: ymd(e0) };
  }


 // ---------- Months (explicit name OR relative "this/next") ----------
// 2A) Explicit month names like "august", "for august", "aug. 2026", "in september"
const monthNameMatch = q.match(
  /\b(?:for|in|during|throughout)?\s*(jan(?:uary)?|feb(?:ruary)?|mar(?:ch)?|apr(?:il)?|may|jun(?:e)?|jul(?:y)?|aug(?:ust)?|sep(?:t|tember)?|oct(?:ober)?|nov(?:ember)?|dec(?:ember)?)\.?\s*(\d{4})?\b/
);
if (monthNameMatch) {
  const m3 = monthNameMatch[1].slice(0,3); // e.g., "august" -> "aug"
  const year = monthNameMatch[2] ? parseInt(monthNameMatch[2], 10) : (new Date()).getFullYear();
  const idxMap = { jan:0,feb:1,mar:2,apr:3,may:4,jun:5,jul:6,aug:7,sep:8,oct:9,nov:10,dec:11 };
  if (m3 in idxMap) {
    const mi = idxMap[m3];
    const s = new Date(year, mi, 1);
    const e = new Date(year, mi+1, 0);
    s.setHours(0,0,0,0); e.setHours(0,0,0,0);
    return { type: "range", startYmd: ymd(s), endYmd: ymd(e) };
  }
}

// 2B) Relative months still supported
if (/\b(this|current)\s+month\b/.test(q)) {
  const today = new Date();
  const s = new Date(today.getFullYear(), today.getMonth(), 1);
  const e = new Date(today.getFullYear(), today.getMonth()+1, 0);
  s.setHours(0,0,0,0); e.setHours(0,0,0,0);
  return { type: "range", startYmd: ymd(s), endYmd: ymd(e) };
}

if (/\b(next|upcoming)\s+month\b/.test(q)) {
  const today = new Date();
  const s = new Date(today.getFullYear(), today.getMonth()+1, 1);
  const e = new Date(today.getFullYear(), today.getMonth()+2, 0);
  s.setHours(0,0,0,0); e.setHours(0,0,0,0);
  return { type: "range", startYmd: ymd(s), endYmd: ymd(e) };
}
// ---------- End Months ----------

  // Singles
  if (/\btomorrow\b/.test(q)) {
    const t = add(t0, 1);
    return { type: "single", ymd: ymd(t) };
  }
  if (/\btoday\b/.test(q)) {
    return { type: "single", ymd: ymd(t0) };
  }

  // Weekends / end-of-week
  if (/\b(end of (the )?week|eow)\b/.test(q) && !/\bnext\b/.test(q)) {
    const s = startOfWeek(new Date());
    const fri = addDays(s, 5);
    const sat = addDays(s, 6);
    const sun = addDays(s, 6);
    const start = fri;
    const end = (EOW_POLICY === "friday" ? fri : (EOW_POLICY === "saturday" ? sat : sun));
    return { type: "range", startYmd: ymd(start), endYmd: ymd(end) };
  }
  if (/\b(end of next week|eonw)\b/.test(q)) {
    const s = startOfWeek(addDays(new Date(), 7));
    const fri = addDays(s, 5);
    const sat = addDays(s, 6);
    const sun = addDays(s, 6);
    const start = fri;
    const end = (EOW_POLICY === "friday" ? fri : (EOW_POLICY === "saturday" ? sat : sun));
    return { type: "range", startYmd: ymd(start), endYmd: ymd(end) };
  }
  if (/\b(this weekend)\b/.test(q)) {
    const s = startOfWeek(new Date());
    const sat = addDays(s, 6);
    const sun = addDays(s, 6);
    const start = (EOW_POLICY === "friday") ? addDays(s, 6) : sat;
    const end   = (EOW_POLICY === "sunday") ? sun : sat;
    return { type: "range", startYmd: ymd(start), endYmd: ymd(end) };
  }
  if (/\b(next weekend)\b/.test(q)) {
    const s = startOfWeek(addDays(new Date(), 7));
    const sat = addDays(s, 6);
    const sun = addDays(s, 6);
    const start = (EOW_POLICY === "friday") ? addDays(s, 6) : sat;
    const end   = (EOW_POLICY === "sunday") ? sun : sat;
    return { type: "range", startYmd: ymd(start), endYmd: ymd(end) };
  }

  // Fallback: explicit date in the query
  const parsed = chrono.parseDate(query, new Date());
  if (parsed) {
    parsed.setHours(0,0,0,0);
    return { type: "single", ymd: ymd(parsed) };
  }
  return null;
}


     
    function getOpenAIKey() {
      return localStorage.getItem("openai_api_key") || "";
    }
    function getAssemblyKey() {
      return localStorage.getItem("assembly_api_key") || "";
    }
    function saveKeys() {
      localStorage.setItem("openai_api_key", openaiKeyInput.value.trim());
      localStorage.setItem("assembly_api_key", assemblyKeyInput.value.trim());
      apiKeySaved.style.display = "inline";
      setTimeout(() => apiKeySaved.style.display = "none", 1500);
    }
    openaiKeyInput.value = getOpenAIKey();
    assemblyKeyInput.value = getAssemblyKey();
    saveKeysBtn.onclick = saveKeys;

    function loadTasks() {
      categories.forEach(cat => {
        const tasks = JSON.parse(localStorage.getItem(cat)) || [];
        const ul = document.querySelector(`#${cat} ul`);
        ul.innerHTML = "";
        tasks.forEach((taskObj, idx) => {
          const li = document.createElement("li");
          li.style.listStyleType = "none";
          li.appendChild(createTaskRow(cat, taskObj, idx, tasks.length));
          ul.appendChild(li);
        });
      });
    }

    function saveTasks(category, tasks) {
      localStorage.setItem(category, JSON.stringify(tasks));
    }

    function saveTask(category, taskObj) {
      const tasks = JSON.parse(localStorage.getItem(category)) || [];
      tasks.push(taskObj);
      saveTasks(category, tasks);
    }

    function addTask(inputText) {
      const cleaned = preprocessInput(inputText);
      const words = cleaned.trim().split(" ");
      let lastWord = words[words.length - 1];
      lastWord = lastWord.replace(/[.,!?;:]+$/, "");
      const category = extractValidCategory(lastWord);
      if (!category) {
        alert("Category not found at the end of the task. Please end your task with one of: " + categories.join(", "));
        return;
      }
      let taskText = words.slice(0, words.length - 1).join(" ").trim();
      taskText = taskText.replace(/[.,!?;:]+$/, "");
      if (!taskText) {
        alert("Task description is empty.");
        return;
      }
const norm = normalizeTaskTextAndDate(taskText);
const taskObj = { text: norm.cleanText, date: norm.dateISO };
saveTask(category, taskObj);

      
function correctTranscriptNames(text) {
  const corrections = [
    { wrong: ["shravan"], correct: "Sravan" },
    { wrong: ["arsh", "arch"], correct: "Arsshh" },
    { wrong: ["courtney"], correct: "Cortney" },
    { wrong: ["brendan"], correct: "Brandon" },
    { wrong: ["migel"], correct: "Miguel" },
    { wrong: ["shazip", "shazeb"], correct: "Shahzeb" },
    { wrong: ["mareen", "marine", "meh reen"], correct: "Mehreen" },
    { wrong: ["humza"], correct: "Hamza" },
    { wrong: ["shah rose"], correct: "Shahroz" },
    { wrong: ["maywish", "meh wish"], correct: "Mehwish" }
  ];

  let corrected = text;
  corrections.forEach(entry => {
    entry.wrong.forEach(w => {
      const regex = new RegExp("\b" + w + "\b", "gi");
      corrected = corrected.replace(regex, entry.correct);
    });
  });
  return corrected;
}


loadTasks();
    }

    function addTaskFromGPT(taskDesc, category) {
      const normalizedCategory = extractValidCategory(category);
      if (!normalizedCategory) {
        playBeep();
        speakTextWithWebSpeech("Sorry, can you repeat please?");
        transcriptDiv.textContent += "\n‚ö†Ô∏è GPT could not determine a valid category. Please say Home, Shop, Work, or Manager.";
        return;
      }
      let cleanedTask = extractTaskText(taskDesc, normalizedCategory);
   const norm = normalizeTaskTextAndDate(cleanedTask);
const taskObj = { text: norm.cleanText, date: norm.dateISO };
saveTask(normalizedCategory, taskObj);

      loadTasks();
      transcriptDiv.textContent += `\n[Parsed: ${JSON.stringify({task: cleanedTask, category: normalizedCategory})}] ‚Üí Task added.`;
      gptAnswer.textContent = "";
      // speakTextWithWebSpeech("Task added to " + normalizedCategory + " category.");
    }

addManualBtn.onclick = async () => {
  const inputText = manualInput.value.trim();
  manualInput.value = "";

  if (!inputText) return;

  if (inputText.toLowerCase().startsWith("gpt ")) {
    const question = inputText.slice(4).trim().toLowerCase();

    // üÜï Handle "continue" locally, not with GPT
    if (/\b(continue|next|go on|keep going)\b/i.test(question)) {
      await showNextChunk();   // show + speak chunk + footer
      return; // ‚úÖ don't call GPT at all
    }

    // Normal GPT query
    gptAnswer.textContent = "Thinking...";
    const answer = await askGpt(question);

    // Split into chunks and display first chunk
    chunkTasksFromGPT(answer);
    await showNextChunk();   // show + speak chunk + footer
  } else {
    // üìù Task mode
    addTask(inputText);
  }
};


manualInput.addEventListener("keydown", (e) => {
  if (e.key === "Enter") {
    addManualBtn.click();
  }
});

async function routeUserInput(userText) {
  const q = (userText || "").trim();
  if (!q) return "";

  // ADD/CREATE/LOG intent ‚Üí create a task (skip GPT)
  const addCmd = q.match(/^\s*(add|create|log)\s+(task\s*)?(.*)$/i);
  if (addCmd) {
    const taskText = (addCmd[3] || "").trim();
    if (!taskText) {
      const msg = "Tell me what to add, e.g., ‚Äúadd task Meet friends tomorrow‚Äù.";
      if (window.gptAnswer) gptAnswer.textContent = msg;
      return msg;
    }
    addTask(taskText); // <- your normalized add pipeline
    const msg = `Added: ${taskText}`;
    if (window.gptAnswer) gptAnswer.textContent = msg;
    return msg;
  }

  // Otherwise ‚Üí treat as QUERY (date-aware askGpt runs first)
  const answer = await askGpt(q);
  if (window.gptAnswer) gptAnswer.textContent = answer;
  return answer;
}
     
    // ====== BACKUP/RESTORE ======
    exportTasksBtn.onclick = function() {
      const backup = {};
      categories.forEach(cat => {
        backup[cat] = JSON.parse(localStorage.getItem(cat)) || [];
      });
      backupArea.value = JSON.stringify(backup, null, 2);
    };
    importTasksBtn.onclick = function() {
      try {
        const backup = JSON.parse(backupArea.value);
        Object.entries(backup).forEach(([cat, tasks]) => {
          if (categories.includes(cat)) {
            localStorage.setItem(cat, JSON.stringify(tasks));
          }
        });
        loadTasks();
        alert("Tasks restored!");
      } catch (e) {
        alert("Invalid backup JSON.");
      }
    };

    // ====== VOICE & GPT LOGIC ======
    let isRecording = false;
    let isConversation = false;
    let stopConversationFlag = false;
    let ttsSpeaking = false;
    let micMuted = false;
    let mediaRecorder, audioChunks = [];
    let silenceTimeout, audioContext, analyser, source, stream;

// ---- Screen Awake Helper ----
let wakeLock = null;
let videoElement = null;

async function enableScreenAwake() {
  if ('wakeLock' in navigator) {
    try {
      wakeLock = await navigator.wakeLock.request('screen');
      console.log("Wake Lock API active");
    } catch (err) {
      console.warn("Wake Lock failed, falling back:", err);
      startVideoFallback();
    }
  } else {
    startVideoFallback();
  }
}

async function disableScreenAwake() {
  if (wakeLock !== null) {
    try {
      await wakeLock.release();
      console.log("Wake Lock released");
    } catch (err) {
      console.warn("Wake Lock release failed:", err);
    }
    wakeLock = null;
  }
  stopVideoFallback();
}

function startVideoFallback() {
  if (!videoElement) {
    videoElement = document.createElement("video");
videoElement.src = "silent.mp4"; // served from your repo over HTTPS

    videoElement.loop = true;
    videoElement.muted = true;
    videoElement.playsInline = true;
    videoElement.style.display = "none";
    document.body.appendChild(videoElement);
  }
  videoElement.play().catch(err => console.warn("Fallback play error:", err));
  console.log("Fallback video hack active");
}

function stopVideoFallback() {
  if (videoElement) {
    videoElement.pause();
    console.log("Fallback video hack stopped");
  }
}


     
    speakBtn.onclick = async () => {
      await unlockTTS();
      if (isRecording || isConversation) return;
      transcriptDiv.textContent = "";
      gptAnswer.textContent = "";
      await startVoiceInputForTask();
    };

    async function startVoiceInputForTask() {
      playBeep();
      await sleep(250); // Let beep finish before starting mic
      await listenWithSilenceDetection(async (transcript) => {
        addTask(transcript);
        transcriptDiv.textContent += " ‚Üí Task added.";
        gptAnswer.textContent = "";
      }, speakBtn);
    }

    handsFreeBtn.onclick = async () => {
  if (handsFreeBtn.classList.contains("recording")) {
    // üõë Already recording ‚Äî STOP everything
    stopListening(); // this should clean up UI, recognition, GPT, etc.
    handsFreeBtn.classList.remove("recording");
    handsFreeBtn.innerText = "ü§ñ Dialog";
      // üîÑ Reload the page to fully reset mic and remove browser mic icon
  location.reload();
    return;
  }

function stopListening() {
  try {
    if (recognition && typeof recognition.stop === "function") {
      recognition.stop();
    }
  } catch (e) {
    console.warn("Recognition stop error:", e);
  }

  isRecording = false;
  isConversation = false;

  stopBtn.style.display = "none";
  interruptTTSBtn.style.display = "none";
  muteMicBtn.style.display = "none";

  if (handsFreeBtn) {
    handsFreeBtn.classList.remove("recording");
    handsFreeBtn.innerText = "ü§ñ Dialog";
  }
   // ‚úÖ Add this line to reset transcript UI
  transcriptDiv.innerText = "Your Speech will show here";
  gptAnswer.innerText = "Virtual Assistant's response....";
}

      
  // ‚úÖ Not recording ‚Äî START hands-free conversation
  await unlockTTS();
  if (isRecording || isConversation) return;

  transcriptDiv.textContent = "üéôÔ∏è Listening...";
  gptAnswer.textContent = "";

  isConversation = true;
  stopBtn.style.display = "inline-block";
  interruptTTSBtn.style.display = "inline-block";
  muteMicBtn.style.display = "inline-block";

  handsFreeBtn.classList.add("recording");
  handsFreeBtn.innerText = "‚èπÔ∏è Stop Recording";

  await handsFreeConversation();
};

    stopBtn.onclick = () => {
      stopConversationFlag = true;
      isConversation = false;
      stopBtn.style.display = "none";
      interruptTTSBtn.style.display = "none";
      muteMicBtn.style.display = "none";
      if (isRecording && mediaRecorder) {
        mediaRecorder.stop();
      }
      cleanupAudio();
      disableWakeLock();
   // üîÑ Reload the page (removes mic icon at top of screen)
  location.reload();   
    };

    interruptTTSBtn.onclick = () => {
      window.speechSynthesis.cancel();
      ttsSpeaking = false;
      // The mic will start listening for input after TTS is interrupted
    };

    muteMicBtn.onclick = () => {
      micMuted = !micMuted;
      muteMicBtn.classList.toggle("muted", micMuted);
      muteMicBtn.textContent = micMuted ? "üé§ Unmute Mic" : "üé§ Mute Mic";
    };

    async function handsFreeConversation() {
      let lastGptResponse = "";
      stopConversationFlag = false;
      isConversation = true;
      stopBtn.style.display = "inline-block";
      interruptTTSBtn.style.display = "inline-block";
      muteMicBtn.style.display = "inline-block";
      while (isConversation && !stopConversationFlag) {
        if (micMuted) {
          transcriptDiv.textContent = "Mic muted. Tap Unmute to continue.";
          await new Promise(resolve => {
            const handler = () => {
              if (!micMuted) {
                document.removeEventListener("click", handler);
                resolve();
              }
            };
            document.addEventListener("click", handler);
          });
          continue;
        }
        playBeep();
        await sleep(250); // Let beep finish before starting mic
        transcriptDiv.textContent = "Listening...";
       let userInput = await listenOnceWithSilenceDetection(handsFreeBtn);

// Handle empty or failed STT
if (!userInput || !userInput.trim()) {
  transcriptDiv.textContent = "No clear input. Listening again...";
  await sleep(400);
  playBeep();
  await sleep(250);
  continue;
}


        // Handle stop voice command
        if (/^(stop|disconnect|goodbye|exit|cancel)$/i.test(userInput.trim())) {
          await speakTextWithWebSpeech("Conversation ended.");
          await sleep(400);
          playBeep();
          await sleep(250);
          break;
        }

        gptLoading.style.display = "inline";
if (userInput && userInput.trim().length > 0) {
  transcriptDiv.textContent = `üó£Ô∏è You said: "${userInput.trim()}"\nThinking...`;
} else {
  transcriptDiv.textContent = "Thinking...";
}

        const preprocessedInput = preprocessInput(userInput);
        const toParse = stripBeforeAddOrCreate(preprocessedInput);

        let handled = false;
        try {
         let lower = toParse.trim().toLowerCase();
  // Voice command: "delete task 3 in Manager", "delete task 2 from Home", or "delete task 1 Manager"
  const deleteMatch = toParse.match(/(?:delete|remove)\s+task\s+(\d+)(?:\s+(?:in|from)\s+|\s+)([\w\s]+)/i);
  if (deleteMatch) {
    const number = parseInt(deleteMatch[1]);
    const categoryRaw = deleteMatch[2];
    const category = extractValidCategory(categoryRaw);

    // For debugging: see console log
    console.log("[VoiceDelete] Matched input:", toParse);
    console.log("[VoiceDelete] Extracted number:", number, "Category:", category);

    if (!category) {
      await speakTextWithWebSpeech("Sorry, I couldn't identify the category. Try, for example, 'delete task 2 in Manager'.");
    } else {
      const success = deleteTaskByNumber(category, number);
      if (success) {
        await speakTextWithWebSpeech(`Deleted task number ${number} from ${category}.`);
      } else {
        await speakTextWithWebSpeech(`Couldn't find task number ${number} in ${category}.`);
      }
    }
    handled = true;
  }
// Voice command: move task 2 from home to Manager
// Also supports: move task 2 from home category to Manager category, etc.
const moveMatch = toParse.match(
  /move\s+task\s+(\d+)\s+from\s+([a-z\s]+?)(?:\s+category)?\s+to\s+([a-z\s]+?)(?:\s+category)?\b/i
);
if (moveMatch) {
  const number = parseInt(moveMatch[1]);
  const fromCategoryRaw = moveMatch[2];
  const toCategoryRaw = moveMatch[3];
  const fromCategory = extractValidCategory(fromCategoryRaw);
  const toCategory = extractValidCategory(toCategoryRaw);

  if (!fromCategory || !toCategory) {
    await speakTextWithWebSpeech("Sorry, I couldn't identify one of the categories. Try something like 'move task 2 from Home to Manager category.'");
  } else {
    const success = moveTaskByNumber(fromCategory, number, toCategory);
    if (success) {
      await speakTextWithWebSpeech(`Moved task number ${number} from ${fromCategory} to ${toCategory}.`);
    } else {
      await speakTextWithWebSpeech(`Couldn't find task number ${number} in ${fromCategory}.`);
    }
  }
  handled = true;
}          

// Only treat short commands like "continue", "show next", etc. as pagination
const isPureContinue = /^\s*(continue|go on|keep going|show next|next(?:\s*(?:one|chunk|page))?)\s*$/i.test(lower);
if (isPureContinue) {
  await showNextChunk();   // show + speak chunk + footer
  await sleep(400); 
  playBeep(); 
  await sleep(250);
  handled = true;
  continue;   // ‚úÖ skip GPT call
}

// Normalize "remind me to ..." into "add task ..."
if (/^\s*remind me to\b/i.test(toParse)) {
  toParse = toParse.replace(/^\s*remind me to\b/i, "add task").trim();
  lower = toParse.toLowerCase();
}


        if (lower.startsWith("add ") || lower.startsWith("create ")) {
  // Strip the verb ("add"/"create" and optional "task") and route locally
  const rawTask = toParse.replace(/^\s*(add|create)\s+(task\s*)?/i, "").trim();

  // We require category as the last word (your addTask expects this).
  // Example you should say: "meet friends end of next week Work"
  const lastWord = rawTask.split(/\s+/).pop().replace(/[.,!?;:]+$/, "");
  const valid = extractValidCategory(lastWord);
  if (!valid) {
    gptLoading.style.display = "none";
    await speakTextWithWebSpeech(
      "Please end your task with a category: Home, Shop, Work, or Manager."
    );
    await sleep(400);
    playBeep();
    await sleep(250);
    continue; // wait for a clearer re-utterance
  }

  // Add the task locally (this uses your existing date parsing/normalization)
  addTask(rawTask);
  gptLoading.style.display = "none";

  await speakTextWithWebSpeech(`Task added to ${valid} category.`);
  await sleep(400);
  playBeep();
  await sleep(250);

  handled = true;
  continue; // ‚úÖ skip GPT call
}

        } catch (e) {
          gptLoading.style.display = "none";
          await speakTextWithWebSpeech("Sorry, can you repeat please.");
          await sleep(400);
          playBeep();
          await sleep(250);
          continue;
        }

        if (!handled) {
          try {
      const gptResponse = await askGpt(toParse);
gptLoading.style.display = "none";

// Break filtered result into chunks
chunkTasksFromGPT(gptResponse);

// üöÄ This already handles both showing and speaking
await showNextChunk();



            await sleep(400);
            playBeep();
            await sleep(250);
          } catch (e) {
            gptLoading.style.display = "none";
            await speakTextWithWebSpeech("Sorry, can you repeat please.");
            await sleep(400);
            playBeep();
            await sleep(250);
            continue;
          }
        }
      }
      isConversation = false;
      stopBtn.style.display = "none";
      interruptTTSBtn.style.display = "none";
      muteMicBtn.style.display = "none";
    }

    async function listenWithSilenceDetection(callback, buttonElem) {
  const ASSEMBLYAI_API_KEY = getAssemblyKey();
  if (!ASSEMBLYAI_API_KEY) {
    alert("Please enter and save your AssemblyAI API key.");
    return;
  }

  const SILENCE_THRESHOLD = 0.05;         // Less sensitive to background noise
  const SILENCE_DURATION = 3000;          // Wait 3 seconds of silence before stopping
  const MIN_RECORDING_DURATION = 1500;    // Must record at least 1.5 seconds

  isRecording = true;
  audioChunks = [];
  stream = await navigator.mediaDevices.getUserMedia({ audio: true });
  mediaRecorder = new MediaRecorder(stream);
  mediaRecorder.start();
      enableScreenAwake();
      startVideoFallback();   // <-- keep screen awake fallback
  const recordingStartTime = Date.now();
let activeFrameCount = 0; // ‚úÖ Add here
  buttonElem.textContent = "‚èπÔ∏è Stop Recording";
  buttonElem.classList.add("recording");

  audioContext = new (window.AudioContext || window.webkitAudioContext)();
  source = audioContext.createMediaStreamSource(stream);
  analyser = audioContext.createAnalyser();
  source.connect(analyser);
  analyser.fftSize = 2048;
  const data = new Uint8Array(analyser.fftSize);

function checkSilence() {
  analyser.getByteTimeDomainData(data);
  let sum = 0;
  for (let i = 0; i < data.length; i++) {
    const normalized = (data[i] - 128) / 128;
    sum += normalized * normalized;
  }
  const volume = Math.sqrt(sum / data.length);
const SILENCE_THRESHOLD = Number(document.getElementById("silenceThresholdInput").value) || 0.05;
  // ‚úÖ Debounced detection logic
  if (volume > SILENCE_THRESHOLD) {
    activeFrameCount++;
    if (activeFrameCount >= REQUIRED_ACTIVE_FRAMES) {
      // Real speech detected; cancel any scheduled stop
      if (silenceTimeout) {
        clearTimeout(silenceTimeout);
        silenceTimeout = null;
      }
    }
  } else {
    activeFrameCount = 0;

    // Quit if silence is held long enough
    if (!silenceTimeout && Date.now() - recordingStartTime > MIN_RECORDING_DURATION) {
     const silenceMs = Number(document.getElementById("silenceDurationInput").value) || 3000;

silenceTimeout = setTimeout(() => {
  if (isRecording) {
    mediaRecorder.stop();
    cleanupAudio();
  }
}, silenceMs);

    }
  }

  if (isRecording) {
    requestAnimationFrame(checkSilence);
  }
}


  requestAnimationFrame(checkSilence);

  mediaRecorder.ondataavailable = e => {
    audioChunks.push(e.data);
  };

  mediaRecorder.onstop = async () => {
    isRecording = false;
    buttonElem.textContent = buttonElem === speakBtn ? "üéôÔ∏è Speak" : "ü§ñ Hands Free";
    buttonElem.classList.remove("recording");
    cleanupAudio();
  
    transcriptDiv.textContent = "Uploading and transcribing...";
    const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });

    try {
      const uploadRes = await fetch("https://api.assemblyai.com/v2/upload", {
        method: "POST",
        headers: { "authorization": ASSEMBLYAI_API_KEY },
        body: audioBlob
      });
      const { upload_url } = await uploadRes.json();

      const transcriptRes = await fetch("https://api.assemblyai.com/v2/transcript", {
        method: "POST",
        headers: {
          "authorization": ASSEMBLYAI_API_KEY,
          "content-type": "application/json"
        },
        body: JSON.stringify({ audio_url: upload_url })
      });
      const { id } = await transcriptRes.json();

      let completed = false;
      while (!completed) {
        await new Promise(res => setTimeout(res, 2000));
        const pollingRes = await fetch(`https://api.assemblyai.com/v2/transcript/${id}`, {
          headers: { "authorization": ASSEMBLYAI_API_KEY }
        });
        const data = await pollingRes.json();

 if (data.status === "completed") {
  
        if (!data.text || data.text.trim().split(" ").length < 2) {
          transcriptDiv.textContent = "Too short or unclear. Ignored.";
          await callback(""); // Call callback with empty string to continue
          completed = true;
          return;
        }

        const correctedText = correctTranscriptNames(data.text);
        console.log("‚úÖ AssemblyAI Original:", data.text);
        console.log("‚úèÔ∏è Corrected for GPT:", correctedText);
        transcriptDiv.textContent = correctedText;
        await callback(correctedText);
        completed = true;

}

        else if (data.status === "failed") {
          transcriptDiv.textContent = "Transcription failed.";
          completed = true;
        } else {
          transcriptDiv.textContent = "Transcribing...";
        }
      }
    } catch (err) {
      transcriptDiv.textContent = "Error: " + err.message;
    }
  };
}

    async function listenOnceWithSilenceDetection(buttonElem) {
      return new Promise(resolve => {
        listenWithSilenceDetection((transcript) => resolve(transcript), buttonElem);
      });
    }

    async function extractTaskAndCategoryWithGPT(userInput) {
      const OPENAI_API_KEY = getOpenAIKey();
      if (!OPENAI_API_KEY) {
        alert("Please enter and save your OpenAI API key.");
        return null;
      }
      const validCategories = categories;
      const systemPrompt =
        "You are an API backend. ALWAYS use the extract_task function to add a task and category. NEVER reply conversationally. " +
        "Only use these categories: " + validCategories.join(", ") + ". " +
        "When returning the category, ONLY use exactly one of these. Do not add extra words like 'category', 'list', or 'task'. " +
        "If you cannot determine a valid category, use an empty string for category.";

      const functionSpec = {
        name: "extract_task",
        description: "Extract a single task and its category from the user's request.",
        parameters: {
          type: "object",
          properties: {
            task: { type: "string", description: "The task description" },
            category: { type: "string", enum: validCategories, description: "The category for the task" }
          },
          required: ["task", "category"]
        }
      };

      try {
        const res = await fetch("https://api.openai.com/v1/chat/completions", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": "Bearer " + OPENAI_API_KEY
          },
          body: JSON.stringify({
            model: "gpt-4o",
            messages: [
              { role: "system", content: systemPrompt },
              { role: "user", content: userInput }
            ],
            tools: [
              {
                type: "function",
                function: functionSpec
              }
            ],
            tool_choice: { type: "function", function: { name: "extract_task" } }
          })
        });
        const data = await res.json();
        if (data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.tool_calls) {
          const args = data.choices[0].message.tool_calls[0].function.arguments;
          try {
            return JSON.parse(args);
          } catch (e) {
            transcriptDiv.textContent += `\n[Function call parse error: ${args}]`;
            return null;
          }
        } else {
          transcriptDiv.textContent += `\n[No tool_calls: ${JSON.stringify(data)}]`;
          return null;
        }
      } catch (err) {
        transcriptDiv.textContent += `\n[Function call error: ${err.message}]`;
        return null;
      }
    }

  function cleanupAudio() {
  if (audioContext) {
    audioContext.close();
    audioContext = null;
  }
// ‚ö†Ô∏è Don't stop the mic tracks here, keep stream alive for session
  if (silenceTimeout) {
    clearTimeout(silenceTimeout);
    silenceTimeout = null;
  }
  disableScreenAwake();   // <-- release screen lock or fallback
  stopVideoFallback();
}


   let conversationHistory = [];
const maxHistory = 6;

async function askGpt(userQuestion) {
  const OPENAI_API_KEY = getOpenAIKey();
  if (!OPENAI_API_KEY) {
    alert("Please enter and save your OpenAI API key.");
    return "";
  }

  gptAnswer.textContent = "Thinking...";

  const tasks = getAllTasks(); // [{text, date, category}, ...]

  // First: resolve date/range from the query
  const resolved = resolveQueryDateOrRange(userQuestion);
  const toLine = (t, i) => `${i + 1}. ${t.text} [${t.category}]`;

if (resolved) {
  // derive a YYYY-MM-DD for every task, from saved date OR parsing the text (legacy tasks)
  const deriveYmd = (t) => {
    if (t.date) {
      const d = new Date(t.date); d.setHours(0,0,0,0);
      return ymd(d);
    }
    const p = chrono.parseDate(t.text, new Date());
    if (p) { p.setHours(0,0,0,0); return ymd(p); }
    return null;
  };

  const dated = tasks.map(t => {
    const y = deriveYmd(t);
    return y ? ({ ...t, ymd: y }) : null;
  }).filter(Boolean);

  let matches = [];
  if (resolved.type === "single") {
    matches = dated.filter(t => t.ymd === resolved.ymd);
  } else if (resolved.type === "range") {
    matches = dated.filter(t => t.ymd >= resolved.startYmd && t.ymd <= resolved.endYmd);
  }

  if (matches.length > 0) {
    return matches.map((t, i) => `${i + 1}. ${t.text} [${t.category}]`).join("\n");
  }
  // else fall through to GPT keyword/semantic filter
}


  // Fallback: GPT keyword/semantic filter
  const taskListText = tasks.map((t, i) => toLine(t, i)).join("\n");

  const systemPrompt = `
You are a task filter engine.
Your ONLY job is to read the list of tasks and return ONLY the tasks that directly match the user's request.
- Match exact words and semantically related concepts.
- DO NOT automatically return an entire category unless the user explicitly asks for "all tasks in [Category]".
- DO NOT summarize or explain.
- DO NOT chunk or paginate.
Return only the matching task lines word-for-word, including task number and category.
`;

  const messages = [
    { role: "system", content: systemPrompt },
    {
      role: "user",
      content: `Here is my task list:\n${taskListText}\n\nNow filter ONLY the tasks relevant to:\n"${userQuestion}"\nReturn only the matching lines.`
    }
  ];

  try {
    const res = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": "Bearer " + OPENAI_API_KEY
      },
      body: JSON.stringify({
        model: "gpt-4o",
        messages: messages,
        max_tokens: 2000
      })
    });

    const data = await res.json();
    if (data.choices && data.choices[0]?.message?.content) {
      return data.choices[0].message.content.trim();
    } else if (data.error) {
      return "API Error: " + data.error.message;
    }
    return "No response from GPT.";
  } catch (err) {
    return "Request failed: " + err.message;
  }
}


     // ====== CHUNKING HELPERS ======
let taskChunks = [];
let currentChunkIndex = 0;

function chunkTasksFromGPT(rawText, chunkSize = 6) {
  const lines = rawText.split(/\n+/).map(l => l.trim()).filter(Boolean);
  taskChunks = [];
  for (let i = 0; i < lines.length; i += chunkSize) {
    taskChunks.push(lines.slice(i, i + chunkSize));
  }
  currentChunkIndex = 0;
}

async function showNextChunk() {
  if (currentChunkIndex < taskChunks.length) {
    const chunk = taskChunks[currentChunkIndex];
    const formatted = "<ul>" + chunk.map(line => `<li>${line}</li>`).join('') + "</ul>";
    gptAnswer.innerHTML = formatted;

    const suffix = (currentChunkIndex < taskChunks.length - 1)
      ? "‚û°Ô∏è Get ready for the next chunk. Do you want me to continue?"
      : "‚úÖ End of tasks.";

    gptAnswer.innerHTML += `<p style="margin-top:10px;">${suffix}</p>`;
    currentChunkIndex++;

    // üó£Ô∏è Speak both tasks and suffix
    const chunkText = chunk.join(". ");
    await speakTextWithWebSpeech(chunkText);
    await speakTextWithWebSpeech(
      currentChunkIndex < taskChunks.length ? "Get ready for the next chunk. Do you want me to continue?" : "End of tasks."
    );
  } else {
    gptAnswer.innerHTML = "<p>‚úÖ All tasks shown.</p>";
    await speakTextWithWebSpeech("End of tasks.");
  }
}



    // Platform-specific voice selection
// Restore silence control settings from localStorage
window.addEventListener("load", () => {
  const silenceThresholdInput = document.getElementById("silenceThresholdInput");
  const silenceDurationInput = document.getElementById("silenceDurationInput");

  silenceThresholdInput.value = localStorage.getItem("silenceThreshold") || "0.05";
  silenceDurationInput.value = localStorage.getItem("silenceDuration") || "3000";
});

// Save when user changes values
document.getElementById("silenceThresholdInput").addEventListener("input", e => {
  localStorage.setItem("silenceThreshold", e.target.value);
});
document.getElementById("silenceDurationInput").addEventListener("input", e => {
  localStorage.setItem("silenceDuration", e.target.value);
});

    //JD start
function getBestVoice() {
  const voices = speechSynthesis.getVoices();
  const select = document.getElementById("voiceSelect");
  if (select && voices.length > 0) {
    const selectedIndex = parseInt(select.value, 10);
    return voices[selectedIndex] || voices[0];
  }
  return voices[0];
}

  //JD end

    // Interruptible TTS
   function speakTextWithWebSpeech(text) {
  return new Promise((resolve) => {
    const synth = window.speechSynthesis;
    if (!synth) {
      alert("Speech Synthesis not supported in this browser.");
      resolve();
      return;
    }

    // Wait for voices to load if needed
    const speak = () => {
      const utter = new SpeechSynthesisUtterance(text);
// Use default system voice (browser determines best)
      utter.pitch = 1;
      utter.rate = 0.97;
      utter.onend = () => resolve();
      utter.onerror = () => resolve();
      synth.speak(utter);
    };

    if (speechSynthesis.getVoices().length === 0) {
      // Voices not loaded yet
      speechSynthesis.onvoiceschanged = () => {
        speak();
      };
    } else {
      // Voices already loaded
      speak();
    }
  });
}


    function getAllTasks() {
      const allTasks = [];
      categories.forEach(cat => {
        const catTasks = JSON.parse(localStorage.getItem(cat)) || [];
        catTasks.forEach(taskObj => {
          allTasks.push({ ...taskObj, category: cat });
        });
      });
      return allTasks;
    }

    function showOnlyCategory(cat) {
      categories.forEach(category => {
        document.getElementById(category).classList.toggle('hidden', category !== cat);
      });
      showAllBtn.style.display = "inline-block";
    }

    function showAllCategories() {
      categories.forEach(category => {
        document.getElementById(category).classList.remove('hidden');
      });
      showAllBtn.style.display = "none";
      loadTasks();
    }

    function createTaskRow(category, taskObj, idx, total) {
      const row = document.createElement("div");
      row.className = "task-row";

const taskText = document.createElement("span");
taskText.className = "task-text";

// üëá Add task number (#1, #2, etc. per category)
const taskNumber = idx + 1;
taskText.textContent = `${taskNumber}. ${taskObj.text}`;

      
      if (taskObj.date) {
        const badge = document.createElement("span");
        badge.className = "date-badge";
        const d = new Date(taskObj.date);
        badge.textContent = d.toLocaleDateString(undefined, { year: "numeric", month: "short", day: "numeric" });
        taskText.appendChild(badge);
      }
      const controls = document.createElement("div");
      controls.className = "task-controls";
      const upBtn = document.createElement("button");
      upBtn.textContent = "‚¨ÜÔ∏è";
      upBtn.title = "Move Up";
      upBtn.disabled = idx === 0;
      upBtn.onclick = () => moveTask(category, idx, idx - 1);
      const downBtn = document.createElement("button");
      downBtn.textContent = "‚¨áÔ∏è";
      downBtn.title = "Move Down";
      downBtn.disabled = idx === total - 1;
      downBtn.onclick = () => moveTask(category, idx, idx + 1);
      const topBtn = document.createElement("button");
      topBtn.textContent = "‚è´";
      topBtn.title = "Move to Top";
      topBtn.disabled = idx === 0;
      topBtn.onclick = () => moveTask(category, idx, 0);
      const bottomBtn = document.createElement("button");
      bottomBtn.textContent = "‚è¨";
      bottomBtn.title = "Move to Bottom";
      bottomBtn.disabled = idx === total - 1;
      bottomBtn.onclick = () => moveTask(category, idx, total - 1);
      const dropdown = document.createElement("div");
      dropdown.className = "dropdown";
      const dotsBtn = document.createElement("button");
      dotsBtn.textContent = "‚ãÆ";
      dotsBtn.title = "More";
      dotsBtn.onclick = (e) => {
        e.stopPropagation();
        document.querySelectorAll('.dropdown').forEach(d => {
          if (d !== dropdown) d.classList.remove('show');
        });
        dropdown.classList.toggle("show");
      };
      const dropdownContent = document.createElement("div");
      dropdownContent.className = "dropdown-content";
      const editBtn = document.createElement("button");
      editBtn.textContent = "Edit";
      editBtn.onclick = (e) => {
        e.stopPropagation();
        dropdown.classList.remove("show");
        editTask(category, idx, taskText, row);
      };
      const deleteBtn = document.createElement("button");
      deleteBtn.textContent = "Delete";
      deleteBtn.onclick = (e) => {
        e.stopPropagation();
        dropdown.classList.remove("show");
        deleteTask(category, idx);
      };
      dropdownContent.appendChild(editBtn);
      dropdownContent.appendChild(deleteBtn);
      dropdown.appendChild(dotsBtn);
      dropdown.appendChild(dropdownContent);
      controls.appendChild(upBtn);
      controls.appendChild(downBtn);
      controls.appendChild(topBtn);
      controls.appendChild(bottomBtn);
      controls.appendChild(dropdown);
      row.appendChild(taskText);
      row.appendChild(controls);
      document.addEventListener("click", () => dropdown.classList.remove('show'));
      return row;
    }

    function moveTask(category, fromIdx, toIdx) {
      const tasks = JSON.parse(localStorage.getItem(category)) || [];
      if (fromIdx < 0 || toIdx < 0 || fromIdx >= tasks.length || toIdx >= tasks.length) return;
      const [moved] = tasks.splice(fromIdx, 1);
      tasks.splice(toIdx, 0, moved);
      saveTasks(category, tasks);
      loadTasks();
    }

    function deleteTask(category, idx) {
      const tasks = JSON.parse(localStorage.getItem(category)) || [];
      tasks.splice(idx, 1);
      saveTasks(category, tasks);
      loadTasks();
    }
function deleteTaskByNumber(category, taskNumber) {
  const tasks = JSON.parse(localStorage.getItem(category)) || [];
  const index = taskNumber - 1; // Convert from 1-based (spoken) to 0-based index
  if (index < 0 || index >= tasks.length) return false;
  tasks.splice(index, 1);
  saveTasks(category, tasks);
  loadTasks();
  return true; // Deletion was successful
}    

function moveTaskByNumber(fromCategory, taskNumber, toCategory) {
  const fromTasks = JSON.parse(localStorage.getItem(fromCategory)) || [];
  const index = taskNumber - 1; // 1-based to 0-based index
  if (index < 0 || index >= fromTasks.length) return false;
  const [movedTask] = fromTasks.splice(index, 1);
  saveTasks(fromCategory, fromTasks);

  // Add to destination category
  const toTasks = JSON.parse(localStorage.getItem(toCategory)) || [];
  toTasks.push(movedTask);
  saveTasks(toCategory, toTasks);

  loadTasks();
  return true;
}    
    function editTask(category, idx, taskTextElem, row) {
      const tasks = JSON.parse(localStorage.getItem(category)) || [];
      const oldTaskObj = tasks[idx];
      const input = document.createElement("input");
      input.type = "text";
      input.className = "edit-input";
      input.value = oldTaskObj.text;
      taskTextElem.replaceWith(input);
      input.focus();
      function saveEdit() {
        const newText = input.value.trim();
        if (newText) {
        const norm = normalizeTaskTextAndDate(newText);
tasks[idx] = { text: norm.cleanText, date: norm.dateISO };

          saveTasks(category, tasks);
          loadTasks();
        } else {
          alert("Task cannot be empty.");
        }
      }
      input.onkeydown = (e) => {
        if (e.key === "Enter") saveEdit();
        if (e.key === "Escape") loadTasks();
      };
      input.onblur = saveEdit;
    }

    loadTasks();
   // to clean up the mic
     window.addEventListener("beforeunload", () => {
  if (recognition && typeof recognition.stop === "function") {
    recognition.stop();
  }
  isRecording = false;
  isConversation = false;
});
  </script>
</body>
</html>
