<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hands-Free Task Manager</title>
    <script src="chrono.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            padding: 16px;
            max-width: 600px;
            margin: auto;
            font-size: 18px;
            line-height: 1.6;
            background-color: #fff;
        }

        button {
            padding: 14px 24px;
            font-size: 20px;
            margin-top: 12px;
            border-radius: 6px;
            cursor: pointer;
            min-height: 44px;
            box-sizing: border-box;
        }

        input[type="text"], input[type="number"], textarea {
            width: 100%;
            padding: 16px;
            font-size: 20px;
            border-radius: 8px;
            margin-top: 10px;
            box-sizing: border-box;
        }

        h2, h3 {
            font-size: 24px;
            margin-top: 24px;
        }

        #transcript, #gptAnswer {
            margin-top: 20px;
            padding: 16px;
            border-radius: 6px;
            min-height: 30px;
            background: #e0f7fa;
            font-size: 18px;
            white-space: pre-wrap;
        }

        .category {
            margin-top: 20px;
        }

        .category h3 {
            font-size: 22px;
            font-weight: bold;
        }

        .category ul {
            padding-left: 0;
            list-style: none;
        }

        .task-row {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            background: #e0f7fa;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 12px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        .task-text {
            font-size: 24px !important;
            font-weight: normal !important;
            line-height: 1.4;
        }

        .task-controls {
            margin-top: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .task-controls button {
            flex: 1 1 auto;
            padding: 12px 16px;
            font-size: 20px;
            min-width: 44px;
            min-height: 44px;
        }

        .dropdown {
            position: relative;
            display: inline-block;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            right: 0;
            background-color: #f9f9f9;
            min-width: 100px;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
            z-index: 1;
            border-radius: 4px;
            overflow: hidden;
        }

        .dropdown-content button {
            color: black;
            padding: 8px 12px;
            text-align: left;
            text-decoration: none;
            display: block;
            border: none;
            background: none;
            width: 100%;
            font-size: 14px;
            cursor: pointer;
        }

        .dropdown-content button:hover {
            background-color: #f1f1f1;
        }

        .dropdown.show .dropdown-content {
            display: block;
        }

        .edit-input {
            width: 80%;
            padding: 3px 6px;
            font-size: 15px;
        }

        .hidden {
            display: none !important;
        }

        .date-badge {
            background: #e0e0e0;
            color: #333;
            border-radius: 4px;
            padding: 2px 7px;
            font-size: 12px;
            margin-left: 8px;
        }

        .category-nav button {
            background-color: #e0f2f1;
            margin-right: 10px;
            margin-top: 10px;
        }

        #backToTop {
            position: fixed;
            bottom: 20px;
            left: 10px;
            padding: 10px 14px;
            font-size: 16px;
            background-color: #d0d0d0;
            border-radius: 6px;
            cursor: pointer;
            display: none;
            z-index: 999;
        }

        .control-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 12px;
        }

        .control-buttons button {
            font-size: 14px;
            padding: 8px 12px;
            flex: 1;
            white-space: nowrap;
            transition: opacity 0.3s ease;
        }

        #stopBtn, #interruptTTSBtn, #muteMicBtn {
            display: none;
        }

        #speakBtn.recording, #handsFreeBtn.recording {
            background: #d32f2f;
            color: #fff;
        }

        #interruptTTSBtn, #muteMicBtn {
            background: #fbc02d;
            color: #222;
        }

        #muteMicBtn.muted {
            background: #bdbdbd;
            color: #666;
        }

        .api-inputs {
            margin-bottom: 16px;
        }

        .api-inputs label {
            display: block;
            margin-top: 8px;
        }

        .task-input {
            margin-top: 20px;
        }

        @media (max-width: 600px) {
            body {
                font-size: 18px;
                padding: 14px;
            }
            .task-text {
                font-size: 24px;
            }
            .task-controls button {
                font-size: 20px;
                padding: 12px 16px;
                min-height: 48px;
            }
            input[type="text"] {
                font-size: 20px;
                padding: 14px;
                width: 100%;
            }
            button {
                font-size: 20px;
                padding: 14px 20px;
            }
            .category h3 {
                font-size: 22px;
                margin-top: 24px;
            }
            #gptAnswer, #transcript {
                font-size: 20px;
                line-height: 1.6;
            }
        }
    </style>
</head>
<body>
    <h2 style="text-align:center; margin-top: 10px;">JD's Virtual Voice Assistant</h2>
    <p style="text-align:center; font-style: italic; font-size: 0.95em; margin-top: -8px; color: #555;">Talk. Track. Triumph!</p>

    <button id="speakBtn">üéôÔ∏è Speak</button>
    <button id="handsFreeBtn">ü§ñ Dialog</button>
    
    <div class="control-buttons">
        <button id="stopBtn">üõë Stop</button>
        <button id="interruptTTSBtn">üîá Interrupt</button>
        <button id="muteMicBtn">üé§ Mute</button>
    </div>

    <span id="gptLoading" style="color: #d32f2f; display: none;">Thinking...</span>
    <div id="transcript" style="color: #888;">Your Speech will show here...</div>
    <div id="gptAnswer" style="color: #888;">Virtual Assistant's response....</div>

    <div class="category-nav">
        <button onclick="scrollToCategory('Home')">üè† Home</button>
        <button onclick="scrollToCategory('Shop')">üõí Shop</button>
        <button onclick="scrollToCategory('Work')">üíº Work</button>
        <button onclick="scrollToCategory('Manager')">üëî Manager</button>
    </div>

    <div class="task-input">
        <input type="text" id="manualInput" placeholder="Enter task and category at end (e.g. Buy milk Manager)" />
        <button id="addManualBtn">Add Task Manually</button>
    </div>

    <button id="showAllBtn" style="display:none;">Show All Tasks</button>

    <div id="categories">
        <div class="category" id="Home">
            <h3>Home</h3>
            <ul></ul>
        </div>
        <div class="category" id="Shop">
            <h3>Shop</h3>
            <ul></ul>
        </div>
        <div class="category" id="Work">
            <h3>Work</h3>
            <ul></ul>
        </div>
        <div class="category" id="Manager">
            <h3>Manager</h3>
            <ul></ul>
        </div>
    </div>

    <h3>üéöÔ∏è Settings</h3>
    <div style="margin-top: 16px;">
        <label>
            Silence Threshold:
            <input type="number" id="silenceThresholdInput" min="0.001" max="0.2" step="0.001" value="0.05" />
        </label>
        <label style="margin-left: 10px;">
            Silence Duration (ms):
            <input type="number" id="silenceDurationInput" min="500" max="10000" step="100" value="3000" />
        </label>
    </div>

    <button id="exportTasksBtn">Export Tasks (Backup)</button>
    <button id="importTasksBtn">Import Tasks</button>
    <textarea id="backupArea" style="width:100%;height:80px;" placeholder="Backup JSON will appear here. Paste here to restore."></textarea>

    <div class="api-inputs">
        <label>
            OpenAI API Key:
            <input type="text" id="openaiKey" placeholder="Paste your OpenAI API Key" autocomplete="off" />
        </label>
        <label>
            AssemblyAI API Key:
            <input type="text" id="assemblyKey" placeholder="Paste your AssemblyAI API Key" autocomplete="off" />
        </label>
        <button id="saveKeysBtn">Save API Keys</button>
        <span id="apiKeySaved" style="color: green; display: none;">‚úîÔ∏è Saved!</span>
    </div>

    <button id="backToTop" onclick="scrollToTop()">üîù Back to Top</button>

    <script>
        function scrollToCategory(id) {
            const el = document.getElementById(id);
            if (el) el.scrollIntoView({ behavior: 'smooth' });
        }

        function scrollToTop() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        window.addEventListener('scroll', () => {
            const btn = document.getElementById('backToTop');
            btn.style.display = window.scrollY > 300 ? 'block' : 'none';
        });

        function correctTranscriptNames(text) {
            const corrections = [
                { wrong: ["shravan", "shivan"], correct: "Sravan" },
                { wrong: ["arsh", "arch", "arish", "arush"], correct: "Arsshh" },
                { wrong: ["courtney"], correct: "Cortney" },
                { wrong: ["brendan"], correct: "Brandon" },
                { wrong: ["migel"], correct: "Miguel" },
                { wrong: ["shazip", "shazeb", "shahzeh"], correct: "Shahzeb" },
                { wrong: ["mareen", "marine", "meh reen", "mahreen", "mehren"], correct: "Mehreen" },
                { wrong: ["humza"], correct: "Hamza" },
                { wrong: ["shah rose", "cheros", "shadows", "sheroz", "cheroz", "chehreau's", "sharrow's"], correct: "Shahroz" },
                { wrong: ["maywish", "meh wish"], correct: "Mehwish" },
                { wrong: ["ametraj", "amatraj"], correct: "Amitraj" }
            ];

            let corrected = text;
            corrections.forEach(entry => {
                entry.wrong.forEach(w => {
                    const regex = new RegExp("\\b" + w.replace(/ /g, "\\s+") + "\\b", "gi");
                    corrected = corrected.replace(regex, entry.correct);
                });
            });
            return corrected;
        }

        // ====== CONFIG ======
        const SILENCE_THRESHOLD = Number(document.getElementById("silenceThresholdInput").value) || 0.05;
        const SILENCE_DURATION = Number(document.getElementById("silenceDurationInput").value) || 3000;
        const MIC_THRESHOLD = 0.03;
        const REQUIRED_ACTIVE_FRAMES = 5;

        // ====== NEW BEEP FUNCTION (Web Audio API) ======
        function playBeep(frequency = 1500, duration = 120) {
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = ctx.createOscillator();
                const gain = ctx.createGain();
                oscillator.type = 'sine';
                oscillator.frequency.value = frequency;
                oscillator.connect(gain);
                gain.connect(ctx.destination);
                oscillator.start();
                gain.gain.setValueAtTime(1, ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0, ctx.currentTime + duration / 1000);
                oscillator.stop(ctx.currentTime + duration / 1000);
                oscillator.onended = () => ctx.close();
            } catch (e) {}
        }

        // ====== DOM ELEMENTS ======
        const openaiKeyInput = document.getElementById("openaiKey");
        const assemblyKeyInput = document.getElementById("assemblyKey");
        const saveKeysBtn = document.getElementById("saveKeysBtn");
        const apiKeySaved = document.getElementById("apiKeySaved");
        const speakBtn = document.getElementById("speakBtn");
        const handsFreeBtn = document.getElementById("handsFreeBtn");
        const stopBtn = document.getElementById("stopBtn");
        const interruptTTSBtn = document.getElementById("interruptTTSBtn");
        const muteMicBtn = document.getElementById("muteMicBtn");
        const transcriptDiv = document.getElementById("transcript");
        const manualInput = document.getElementById("manualInput");
        const addManualBtn = document.getElementById("addManualBtn");
        const showAllBtn = document.getElementById("showAllBtn");
        const gptAnswer = document.getElementById("gptAnswer");
        const gptLoading = document.getElementById("gptLoading");
        const exportTasksBtn = document.getElementById("exportTasksBtn");
        const importTasksBtn = document.getElementById("importTasksBtn");
        const backupArea = document.getElementById("backupArea");

        const categories = ["Home", "Shop", "Work", "Manager"];

        // ==== TTS Unlock Logic ====
        let ttsUnlocked = false;
        function unlockTTS() {
            return new Promise(resolve => {
                if (ttsUnlocked) return resolve();
                let utter = new SpeechSynthesisUtterance(" ");
                utter.onend = () => {
                    ttsUnlocked = true;
                    resolve();
                };
                utter.onerror = () => {
                    ttsUnlocked = true;
                    resolve();
                };
                window.speechSynthesis.speak(utter);
            });
        }

        function sleep(ms) {
            return new Promise(r => setTimeout(r, ms));
        }

        function stripBeforeAddOrCreate(input) {
            let match = input.match(/\b(add|create)\b/i);
            if (match) {
                return input.slice(match.index).trim();
            }
            return input.trim();
        }

        function extractValidCategory(raw) {
            if (!raw) return null;
            let normalized = raw.toLowerCase();
            normalized = normalized.replace(/[\.\,\!\?\;\:]+/g, '');
            normalized = normalized.replace(/\b(category|list|task|under|the|a|an|in|to|for|on|of|as|at|with|by|from|into|onto|and|or|add|new|my)\b/g, '').trim();
            normalized = normalized.replace(/\s{2,}/g, ' ').trim();
            
            for (const cat of categories) {
                if (normalized === cat.toLowerCase()) return cat;
                if (normalized.includes(cat.toLowerCase())) return cat;
            }
            return null;
        }

        function preprocessInput(input) {
            return input.replace(/[\.\,\!\?\;\:]+/g, ' ').replace(/\s+/g, ' ').trim();
        }

        function extractTaskText(input, category) {
            if (!category) return input.trim();
            const regex = new RegExp(`\\b${category}\\b[\\.\\!\\?\\s]*$`, 'i');
            return input.replace(regex, '').trim();
        }

        function getOpenAIKey() {
            return localStorage.getItem("openai_api_key") || "";
        }

        function getAssemblyKey() {
            return localStorage.getItem("assembly_api_key") || "";
        }

        function saveKeys() {
            localStorage.setItem("openai_api_key", openaiKeyInput.value.trim());
            localStorage.setItem("assembly_api_key", assemblyKeyInput.value.trim());
            apiKeySaved.style.display = "inline";
            setTimeout(() => apiKeySaved.style.display = "none", 1500);
        }

        openaiKeyInput.value = getOpenAIKey();
        assemblyKeyInput.value = getAssemblyKey();
        saveKeysBtn.onclick = saveKeys;

        // ====== TASK MANAGEMENT ======
        function createTaskRow(category, taskObj, index, totalTasks) {
            const taskRow = document.createElement("div");
            taskRow.className = "task-row";

            const taskText = document.createElement("div");
            taskText.className = "task-text";
            taskText.textContent = taskObj.text;

            if (taskObj.date) {
                const dateBadge = document.createElement("span");
                dateBadge.className = "date-badge";
                dateBadge.textContent = new Date(taskObj.date).toLocaleDateString();
                taskText.appendChild(dateBadge);
            }

            const controls = document.createElement("div");
            controls.className = "task-controls";

            // Edit button
            const editBtn = document.createElement("button");
            editBtn.textContent = "‚úèÔ∏è Edit";
            editBtn.onclick = () => editTask(category, index, taskText, taskObj);

            // Delete button
            const deleteBtn = document.createElement("button");
            deleteBtn.textContent = "üóëÔ∏è Delete";
            deleteBtn.onclick = () => deleteTask(category, index);

            // Move buttons
            const moveUpBtn = document.createElement("button");
            moveUpBtn.textContent = "‚¨ÜÔ∏è";
            moveUpBtn.disabled = index === 0;
            moveUpBtn.onclick = () => moveTask(category, index, -1);

            const moveDownBtn = document.createElement("button");
            moveDownBtn.textContent = "‚¨áÔ∏è";
            moveDownBtn.disabled = index === totalTasks - 1;
            moveDownBtn.onclick = () => moveTask(category, index, 1);

            controls.appendChild(editBtn);
            controls.appendChild(deleteBtn);
            controls.appendChild(moveUpBtn);
            controls.appendChild(moveDownBtn);

            taskRow.appendChild(taskText);
            taskRow.appendChild(controls);

            return taskRow;
        }

        function editTask(category, index, taskTextElement, taskObj) {
            const input = document.createElement("input");
            input.type = "text";
            input.value = taskObj.text;
            input.className = "edit-input";
            
            taskTextElement.innerHTML = "";
            taskTextElement.appendChild(input);
            input.focus();

            input.onblur = input.onkeydown = (e) => {
                if (e.type === "keydown" && e.key !== "Enter") return;
                
                const tasks = JSON.parse(localStorage.getItem(category)) || [];
                tasks[index].text = input.value;
                saveTasks(category, tasks);
                loadTasks();
            };
        }

        function deleteTask(category, index) {
            const tasks = JSON.parse(localStorage.getItem(category)) || [];
            tasks.splice(index, 1);
            saveTasks(category, tasks);
            loadTasks();
        }

        function moveTask(category, index, direction) {
            const tasks = JSON.parse(localStorage.getItem(category)) || [];
            const newIndex = index + direction;
            
            if (newIndex >= 0 && newIndex < tasks.length) {
                [tasks[index], tasks[newIndex]] = [tasks[newIndex], tasks[index]];
                saveTasks(category, tasks);
                loadTasks();
            }
        }

        function loadTasks() {
            categories.forEach(cat => {
                const tasks = JSON.parse(localStorage.getItem(cat)) || [];
                const ul = document.querySelector(`#${cat} ul`);
                ul.innerHTML = "";
                tasks.forEach((taskObj, idx) => {
                    const li = document.createElement("li");
                    li.style.listStyleType = "none";
                    li.appendChild(createTaskRow(cat, taskObj, idx, tasks.length));
                    ul.appendChild(li);
                });
            });
        }

        function saveTasks(category, tasks) {
            localStorage.setItem(category, JSON.stringify(tasks));
        }

        function saveTask(category, taskObj) {
            const tasks = JSON.parse(localStorage.getItem(category)) || [];
            tasks.push(taskObj);
            saveTasks(category, tasks);
        }

        function addTask(inputText) {
            const cleaned = preprocessInput(inputText);
            const words = cleaned.trim().split(" ");
            let lastWord = words[words.length - 1];
            lastWord = lastWord.replace(/[.,!?;:]+$/, "");
            
            const category = extractValidCategory(lastWord);
            if (!category) {
                alert("Category not found at the end of the task. Please end your task with one of: " + categories.join(", "));
                return;
            }

            let taskText = words.slice(0, words.length - 1).join(" ").trim();
            taskText = taskText.replace(/[.,!?;:]+$/, "");
            
            if (!taskText) {
                alert("Task description is empty.");
                return;
            }

            let parsedDate = chrono.parseDate(taskText);
            const taskObj = {
                text: taskText,
                date: parsedDate ? parsedDate.toISOString() : null
            };

            saveTask(category, taskObj);
            loadTasks();
        }

        function addTaskFromGPT(taskDesc, category) {
            const normalizedCategory = extractValidCategory(category);
            if (!normalizedCategory) {
                playBeep();
                speakTextWithWebSpeech("Sorry, can you repeat please?");
                transcriptDiv.textContent += "\n‚ö†Ô∏è GPT could not determine a valid category. Please say Home, Shop, Work, or Manager.";
                return;
            }

            let cleanedTask = extractTaskText(taskDesc, normalizedCategory);
            let parsedDate = chrono.parseDate(cleanedTask);
            const taskObj = {
                text: cleanedTask,
                date: parsedDate ? parsedDate.toISOString() : null
            };

            saveTask(normalizedCategory, taskObj);
            loadTasks();
            transcriptDiv.textContent += `\n[Parsed: ${JSON.stringify({task: cleanedTask, category: normalizedCategory})}] ‚Üí Task added.`;
            gptAnswer.textContent = "";
        }

        addManualBtn.onclick = () => {
            const inputText = manualInput.value;
            addTask(inputText);
            manualInput.value = "";
        };

        // ====== BACKUP/RESTORE ======
        exportTasksBtn.onclick = function() {
            const backup = {};
            categories.forEach(cat => {
                backup[cat] = JSON.parse(localStorage.getItem(cat)) || [];
            });
            backupArea.value = JSON.stringify(backup, null, 2);
        };

        importTasksBtn.onclick = function() {
            try {
                const backup = JSON.parse(backupArea.value);
                Object.entries(backup).forEach(([cat, tasks]) => {
                    if (categories.includes(cat)) {
                        localStorage.setItem(cat, JSON.stringify(tasks));
                    }
                });
                loadTasks();
                alert("Tasks restored!");
            } catch (e) {
                alert("Invalid backup JSON.");
            }
        };

        // ====== VOICE & GPT LOGIC ======
        let isRecording = false;
        let isConversation = false;
        let stopConversationFlag = false;
        let ttsSpeaking = false;
        let micMuted = false;
        let mediaRecorder, audioChunks = [];
        let silenceTimeout, audioContext;

        // Speech synthesis function - SINGLE INSTANCE
        function speakTextWithWebSpeech(text) {
            if (!text || ttsSpeaking) return;
            
            // Cancel any existing speech
            window.speechSynthesis.cancel();
            
            ttsSpeaking = true;
            interruptTTSBtn.style.display = "inline-block";
            
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.rate = 0.9;
            utterance.pitch = 1;
            utterance.volume = 1;
            
            utterance.onend = () => {
                ttsSpeaking = false;
                interruptTTSBtn.style.display = "none";
            };
            
            utterance.onerror = () => {
                ttsSpeaking = false;
                interruptTTSBtn.style.display = "none";
            };
            
            window.speechSynthesis.speak(utterance);
        }

        // Interrupt TTS
        interruptTTSBtn.onclick = () => {
            window.speechSynthesis.cancel();
            ttsSpeaking = false;
            interruptTTSBtn.style.display = "none";
        };

        // Initialize the app
        loadTasks();

        // Add your remaining voice recognition and GPT integration code here...
        // (The rest of your JavaScript functions for speech recognition, GPT API calls, etc.)

    </script>
</body>
</html>
