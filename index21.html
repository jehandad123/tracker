<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Hands-Free Task Manager</title>
  <script src="https://cdn.jsdelivr.net/npm/chrono-node@2.3.4/dist/chrono.min.js"></script>
  <style>
    body { font-family: sans-serif; padding: 20px; max-width: 800px; margin: auto; }
    button { padding: 10px 20px; font-size: 16px; margin-top: 10px; cursor: pointer; }
    .category { margin-top: 20px; }
    .category h3 { margin-bottom: 5px; }
    ul { list-style-type: none; padding: 0; }
    .task-row { display: flex; align-items: center; margin-bottom: 8px; }
    .task-number { width: 30px; font-weight: bold; }
    .task-text { flex: 1; }
    .task-controls { margin-left: 10px; }
    .date-badge {
      background: #e0e0e0;
      color: #333;
      border-radius: 4px;
      padding: 2px 6px;
      font-size: 12px;
      margin-left: 8px;
    }
    .edit-input {
      width: 100%;
      padding: 4px;
    }
  </style>
</head>
<body>
  <h2>üéôÔ∏è Hands-Free Task Manager</h2>

  <div class="api-inputs">
    <label>
      OpenAI API Key:
      <input type="text" id="openaiKey" style="width:100%;" />
    </label>
    <label>
      AssemblyAI API Key:
      <input type="text" id="assemblyKey" style="width:100%;" />
    </label>
    <button id="saveKeysBtn">Save API Keys</button>
    <span id="apiKeySaved" style="color: green; margin-left: 10px; display:none;">‚úîÔ∏è Saved</span>
  </div>

  <div class="task-input">
    <input type="text" id="manualInput" placeholder="e.g. Buy dog food Home" style="width:80%;" />
    <button id="addManualBtn">Add Task</button>
  </div>

  <button id="speakBtn">üé§ Speak</button>
  <button id="handsFreeBtn">ü§ñ Hands Free</button>
  <button id="stopBtn" style="display:none;">‚õî Stop</button>

  <div id="transcript" style="margin-top: 15px; font-style: italic;"></div>

  <div id="categories">
    <div class="category" id="Home">
      <h3>üè† Home</h3>
      <ul></ul>
    </div>
    <div class="category" id="Today">
      <h3>üìÖ Today</h3>
      <ul></ul>
    </div>
    <div class="category" id="Urgent">
      <h3>‚ö†Ô∏è Urgent</h3>
      <ul></ul>
    </div>
    <div class="category" id="Shop">
      <h3>üõí Shop</h3>
      <ul></ul>
    </div>
  </div>

  <h4>Backup & Restore</h4>
  <button id="exportTasksBtn">Export Tasks</button>
  <button id="importTasksBtn">Import Tasks</button>
  <textarea id="backupArea" placeholder="Paste JSON here to restore..." style="width:100%;height:80px;margin-top:6px;"></textarea>

  <script>
    const categories = ["Home", "Today", "Urgent", "Shop"];

    // ---------- Storage & Task List Logic ----------
    function saveTasks(category, tasks) {
      localStorage.setItem(category, JSON.stringify(tasks));
    }

    function loadTasks() {
      categories.forEach(cat => {
        const tasks = JSON.parse(localStorage.getItem(cat)) || [];
        const ul = document.querySelector(`#${cat} ul`);
        ul.innerHTML = "";
        tasks.forEach((task, idx) => {
          const li = document.createElement("li");
          const row = document.createElement("div");
          row.className = "task-row";

          const numberSpan = document.createElement("span");
          numberSpan.className = "task-number";
          numberSpan.textContent = (idx + 1) + ".";

          const text = document.createElement("span");
          text.className = "task-text";
          text.textContent = task.text;
          // Date badge
          if (task.date) {
            const date = new Date(task.date);
            const badge = document.createElement("span");
            badge.className = "date-badge";
            badge.textContent = date.toLocaleDateString();
            text.appendChild(badge);
          }

          // Controls for move/edit/delete via dropdown remain here if wanted
          row.appendChild(numberSpan);
          row.appendChild(text);
          li.appendChild(row);
          ul.appendChild(li);
        });
      });
    }

    // ---------- Text-to-Speech, Samantha Only ----------
    function speakTextWithWebSpeech(text) {
      return new Promise(resolve => {
        const synth = window.speechSynthesis;
        const speak = () => {
          const utter = new SpeechSynthesisUtterance(text);
          const samantha = synth.getVoices().find(v => v.name && v.name.toLowerCase().includes("samantha"));
          utter.voice = samantha || null;
          synth.speak(utter);
          utter.onend = resolve;
        };
        if (synth.getVoices().length === 0) {
          synth.onvoiceschanged = speak;
        } else {
          speak();
        }
      });
    }

    // --------- API Key Utilities ----------
    function getOpenAIKey() { return localStorage.getItem("openai_api_key") || ""; }
    function getAssemblyKey() { return localStorage.getItem("assembly_api_key") || ""; }
    function saveKeys() {
      localStorage.setItem("openai_api_key", openaiKeyInput.value.trim());
      localStorage.setItem("assembly_api_key", assemblyKeyInput.value.trim());
      apiKeySaved.style.display = "inline";
      setTimeout(() => apiKeySaved.style.display = "none", 1500);
    }
    openaiKeyInput.value = getOpenAIKey();
    assemblyKeyInput.value = getAssemblyKey();
    saveKeysBtn.onclick = saveKeys;
    // ---------- Special Command Handling: Edit & Delete ----------
    function handleSpecialCommands(inputText) {
      // Delete: e.g. "Delete task 3 from Home"
      let m = inputText.match(/delete\s+task\s+(\d+)\s+from\s+(.+)/i);
      if (m) {
        const idx = parseInt(m[1], 10) - 1;
        const cat = extractValidCategory(m[2]);
        if (!cat) {
          alert("Could not determine the category in your delete command.");
          return true;
        }
        const tasks = JSON.parse(localStorage.getItem(cat)) || [];
        if (idx < 0 || idx >= tasks.length) {
          alert("Task number not found in " + cat);
          return true;
        }
        tasks.splice(idx, 1);
        saveTasks(cat, tasks);
        loadTasks();
        speakTextWithWebSpeech("Task deleted from " + cat);
        return true;
      }

      // Edit: e.g. "Edit task 3 Home to Buy groceries Home"
      m = inputText.match(/edit\s+task\s+(\d+)\s+(\w+)\s+to\s+(.+)/i);
      if (m) {
        const idx = parseInt(m[1], 10) - 1;
        const cat = extractValidCategory(m[2]);
        const newText = m[3].trim();
        if (!cat || !newText) {
          alert("Invalid edit command ‚Äî check category and new task text.");
          return true;
        }
        const tasks = JSON.parse(localStorage.getItem(cat)) || [];
        if (idx < 0 || idx >= tasks.length) {
          alert("Task number not found in " + cat);
          return true;
        }
        let parsedDate = chrono.parseDate(newText);
        tasks[idx] = { text: newText, date: parsedDate ? parsedDate.toISOString() : null };
        saveTasks(cat, tasks);
        loadTasks();
        speakTextWithWebSpeech("Task updated in " + cat);
        return true;
      }
      return false;
    }

    // ---------- Original Add Task Logic (untouched) ----------
    function addTask(inputText) {
      const cleaned = preprocessInput(inputText);
      const words = cleaned.trim().split(" ");
      let lastWord = words[words.length - 1];
      lastWord = lastWord.replace(/[.,!?;:]+$/, "");
      const category = extractValidCategory(lastWord);
      if (!category) {
        alert("Category not found at the end of the task. Please end your task with one of: " + categories.join(", "));
        return;
      }
      let taskText = words.slice(0, words.length - 1).join(" ").trim();
      taskText = taskText.replace(/[.,!?;:]+$/, "");
      if (!taskText) {
        alert("Task description is empty.");
        return;
      }
      let parsedDate = chrono.parseDate(taskText);
      const taskObj = { text: taskText, date: parsedDate ? parsedDate.toISOString() : null };
      saveTask(category, taskObj);
      loadTasks();
      speakTextWithWebSpeech("Task added to " + category);
    }

    function addTaskFromGPT(taskDesc, category) {
      const normalizedCategory = extractValidCategory(category);
      if (!normalizedCategory) {
        playBeep();
        speakTextWithWebSpeech("Sorry, can you repeat please?");
        transcriptDiv.textContent += "\n‚ö†Ô∏è GPT could not determine a valid category. Please say Home, Today, Urgent, or Shop.";
        return;
      }
      let cleanedTask = extractTaskText(taskDesc, normalizedCategory);
      let parsedDate = chrono.parseDate(cleanedTask);
      const taskObj = { text: cleanedTask, date: parsedDate ? parsedDate.toISOString() : null };
      saveTask(normalizedCategory, taskObj);
      loadTasks();
      transcriptDiv.textContent += `\n[Parsed: ${JSON.stringify({task: cleanedTask, category: normalizedCategory})}] ‚Üí Task added.`;
      gptAnswer.textContent = "";
      speakTextWithWebSpeech("Task added to " + normalizedCategory + " category.");
    }

    // ---------- Helper: Decides Between Command or Add ----------
    function tryAddOrSpecialCommand(inputText) {
      if (handleSpecialCommands(inputText)) return;
      addTask(inputText);
    }

    // Manual add button
    addManualBtn.onclick = () => {
      const inputText = manualInput.value;
      tryAddOrSpecialCommand(inputText);
      manualInput.value = "";
    };

        // ---------- Backup & Restore ----------
    exportTasksBtn.onclick = function() {
      const backup = {};
      categories.forEach(cat => {
        backup[cat] = JSON.parse(localStorage.getItem(cat)) || [];
      });
      backupArea.value = JSON.stringify(backup, null, 2);
    };
    importTasksBtn.onclick = function() {
      try {
        const backup = JSON.parse(backupArea.value);
        Object.entries(backup).forEach(([cat, tasks]) => {
          if (categories.includes(cat)) {
            localStorage.setItem(cat, JSON.stringify(tasks));
          }
        });
        loadTasks();
        alert("Tasks restored!");
      } catch (e) {
        alert("Invalid backup JSON.");
      }
    };

    // ---------- Speech Recognition & AssemblyAI Logic ----------
    // --- Speak button: uses AssemblyAI for transcription
    let isRecording = false;
    let isConversation = false;
    let stopConversationFlag = false;
    let ttsSpeaking = false;
    let micMuted = false;
    let mediaRecorder, audioChunks = [];
    let silenceTimeout, audioContext, analyser, source, stream;

    speakBtn.onclick = async () => {
      await unlockTTS();
      if (isRecording || isConversation) return;
      transcriptDiv.textContent = "";
      gptAnswer.textContent = "";
      await startVoiceInputForTask();
    };

    async function startVoiceInputForTask() {
      playBeep();
      await sleep(250); // Let beep finish before starting mic
      await listenWithSilenceDetection(async (transcript) => {
        tryAddOrSpecialCommand(transcript);
        transcriptDiv.textContent += " ‚Üí Task handled.";
        gptAnswer.textContent = "";
      }, speakBtn);
    }

    // --- Hands Free (Conversation) ---
    handsFreeBtn.onclick = async () => {
      await unlockTTS();
      if (isRecording || isConversation) return;
      transcriptDiv.textContent = "";
      gptAnswer.textContent = "";
      isConversation = true;
      stopBtn.style.display = "inline-block";
      await handsFreeConversation();
    };

    stopBtn.onclick = () => {
      stopConversationFlag = true;
      isConversation = false;
      stopBtn.style.display = "none";
      // optional: hide other TTS/mic controls if present
      if (isRecording && mediaRecorder) {
        mediaRecorder.stop();
      }
      cleanupAudio();
    };

    async function handsFreeConversation() {
      let lastGptResponse = "";
      stopConversationFlag = false;
      isConversation = true;
      stopBtn.style.display = "inline-block";
      while (isConversation && !stopConversationFlag) {
        playBeep();
        await sleep(250); // Let beep finish before starting mic
        transcriptDiv.textContent = "Listening...";
        let userInput = await listenOnceWithSilenceDetection(handsFreeBtn);

        if (!userInput || !userInput.trim()) {
          transcriptDiv.textContent = "No clear input. Listening again...";
          await sleep(400);
          playBeep();
          await sleep(250);
          continue;
        }

        // Handle stop voice command
        if (/^(stop|disconnect|goodbye|exit|cancel)$/i.test(userInput.trim())) {
          await speakTextWithWebSpeech("Conversation ended.");
          await sleep(400);
          playBeep();
          await sleep(250);
          break;
        }

        gptLoading && (gptLoading.style.display = "inline");
        transcriptDiv.textContent = "Thinking...";

        const preprocessedInput = preprocessInput(userInput);
        const toParse = stripBeforeAddOrCreate(preprocessedInput);

        let handled = false;
        try {
          const lower = toParse.trim().toLowerCase();
          if (
            lower.startsWith("add ") ||
            lower.startsWith("create ") ||
            lower.startsWith("edit ") ||
            lower.startsWith("delete ")
          ) {
            tryAddOrSpecialCommand(toParse);
            gptLoading && (gptLoading.style.display = "none");
            await speakTextWithWebSpeech("Task handled.");
            await sleep(400);
            playBeep();
            await sleep(250);
            handled = true;
          }
        } catch (e) {
          gptLoading && (gptLoading.style.display = "none");
          await speakTextWithWebSpeech("Sorry, can you repeat please.");
          await sleep(400);
          playBeep();
          await sleep(250);
          continue;
        }

        if (!handled) {
          try {
            const gptResponse = await askGpt(toParse);
            gptLoading && (gptLoading.style.display = "none");
            lastGptResponse = gptResponse;
            await speakTextWithWebSpeech(gptResponse);
            await sleep(400);
            playBeep();
            await sleep(250);
          } catch (e) {
            gptLoading && (gptLoading.style.display = "none");
            await speakTextWithWebSpeech("Sorry, can you repeat please.");
            await sleep(400);
            playBeep();
            await sleep(250);
            continue;
          }
        }
      }
      isConversation = false;
      stopBtn.style.display = "none";
    }

    // --- AssemblyAI microservice mic/voice logic ---
    async function listenWithSilenceDetection(callback, buttonElem) {
      const ASSEMBLYAI_API_KEY = getAssemblyKey();
      if (!ASSEMBLYAI_API_KEY) {
        alert("Please enter and save your AssemblyAI API key.");
        return;
      }

      const SILENCE_THRESHOLD = 0.05;
      const SILENCE_DURATION = 3000;
      const MIN_RECORDING_DURATION = 1500;

      isRecording = true;
      audioChunks = [];
      stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      mediaRecorder = new MediaRecorder(stream);
      mediaRecorder.start();
      const recordingStartTime = Date.now();

      buttonElem.textContent = "‚èπÔ∏è Stop Recording";
      buttonElem.classList.add("recording");

      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      source = audioContext.createMediaStreamSource(stream);
      analyser = audioContext.createAnalyser();
      source.connect(analyser);
      analyser.fftSize = 2048;
      const data = new Uint8Array(analyser.fftSize);

      function checkSilence() {
        analyser.getByteTimeDomainData(data);
        let sum = 0;
        for (let i = 0; i < data.length; i++) {
          const normalized = (data[i] - 128) / 128;
          sum += normalized * normalized;
        }
        const volume = Math.sqrt(sum / data.length);

        if (volume < SILENCE_THRESHOLD) {
          if (!silenceTimeout && Date.now() - recordingStartTime > MIN_RECORDING_DURATION) {
            silenceTimeout = setTimeout(() => {
              if (isRecording) {
                mediaRecorder.stop();
                cleanupAudio();
              }
            }, SILENCE_DURATION);
          }
        } else {
          if (silenceTimeout) {
            clearTimeout(silenceTimeout);
            silenceTimeout = null;
          }
        }

        if (isRecording) {
          requestAnimationFrame(checkSilence);
        }
      }

      requestAnimationFrame(checkSilence);

      mediaRecorder.ondataavailable = e => {
        audioChunks.push(e.data);
      };

      mediaRecorder.onstop = async () => {
        isRecording = false;
        buttonElem.textContent = buttonElem === speakBtn ? "üé§ Speak" : "ü§ñ Hands Free";
        buttonElem.classList.remove("recording");
        cleanupAudio();

        transcriptDiv.textContent = "Uploading and transcribing...";
        const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });

        try {
          const uploadRes = await fetch("https://api.assemblyai.com/v2/upload", {
            method: "POST",
            headers: { "authorization": ASSEMBLYAI_API_KEY },
            body: audioBlob
          });
          const { upload_url } = await uploadRes.json();

          const transcriptRes = await fetch("https://api.assemblyai.com/v2/transcript", {
            method: "POST",
            headers: {
              "authorization": ASSEMBLYAI_API_KEY,
              "content-type": "application/json"
            },
            body: JSON.stringify({ audio_url: upload_url })
          });
          const { id } = await transcriptRes.json();

          let completed = false;
          while (!completed) {
            await new Promise(res => setTimeout(res, 2000));
            const pollingRes = await fetch(`https://api.assemblyai.com/v2/transcript/${id}`, {
              headers: { "authorization": ASSEMBLYAI_API_KEY }
            });
            const data = await pollingRes.json();

            if (data.status === "completed") {
              if (!data.text || data.text.trim().split(" ").length < 2) {
                transcriptDiv.textContent = "Too short or unclear. Ignored.";
                await callback("");
                completed = true;
                return;
              }
              transcriptDiv.textContent = data.text;
              await callback(data.text);
              completed = true;
            }
            else if (data.status === "failed") {
              transcriptDiv.textContent = "Transcription failed.";
              completed = true;
            } else {
              transcriptDiv.textContent = "Transcribing...";
            }
          }
        } catch (err) {
          transcriptDiv.textContent = "Error: " + err.message;
        }
      };
    }

    // --- Listen Once With Timeout to avoid stuck state ---
    function listenOnceWithSilenceDetection(buttonElem) {
      return new Promise(resolve => {
        let timeout = setTimeout(() => {
          resolve("");
        }, 20000); // 20s timeout -- prevents stuck conversation
        listenWithSilenceDetection((transcript) => {
          clearTimeout(timeout);
          resolve(transcript);
        }, buttonElem);
      });
    }
    // ---------- GPT Integration & Helpers ----------
    async function askGpt(userQuestion) {
      const OPENAI_API_KEY = getOpenAIKey();
      if (!OPENAI_API_KEY) {
        alert("Please enter and save your OpenAI API key.");
        return "";
      }
      gptAnswer && (gptAnswer.textContent = "");
      // Concatenate all tasks for context
      const allTasks = [];
      categories.forEach(cat => {
        const catTasks = JSON.parse(localStorage.getItem(cat)) || [];
        catTasks.forEach(taskObj => {
          allTasks.push({ ...taskObj, category: cat });
        });
      });
      const prompt = `Here are my tasks:\n${allTasks.map(
          t => `- [${t.category}] ${t.text}${t.date ? " (" + t.date.slice(0,10) + ")" : ""}`
        ).join('\n')}\n\nUser question: ${userQuestion}\n\nAnswer in a clear, concise way. If dates are mentioned, use the task dates to filter.`;
      try {
        const res = await fetch("https://api.openai.com/v1/chat/completions", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": "Bearer " + OPENAI_API_KEY
          },
          body: JSON.stringify({
            model: "gpt-4o",
            messages: [
              {role: "system", content: "You are a helpful personal task assistant."},
              {role: "user", content: prompt}
            ]
          })
        });
        const data = await res.json();
        let answer = "";
        if (
          data.choices && data.choices[0] &&
          data.choices[0].message &&
          data.choices[0].message.content
        ) {
          answer = data.choices[0].message.content.trim();
          gptAnswer && (gptAnswer.textContent = answer);
        } else if (data.error) {
          answer = "API Error: " + data.error.message;
          gptAnswer && (gptAnswer.textContent = answer);
        } else {
          answer = "No response from GPT.";
          gptAnswer && (gptAnswer.textContent = answer);
        }
        return answer;
      } catch (err) {
        gptAnswer && (gptAnswer.textContent = "Request failed: " + err.message);
        return "Request failed: " + err.message;
      }
    }

    // ---------- Miscellaneous Helpers ----------
    function preprocessInput(input) {
      return input.replace(/[\.\,\!\?\;\:]+/g, ' ').replace(/\s+/g, ' ').trim();
    }

    function extractValidCategory(raw) {
      if (!raw) return null;
      let normalized = raw.toLowerCase();
      normalized = normalized.replace(/[\.\,\!\?\;\:]+/g, '');
      normalized = normalized.replace(/\b(category|list|task|under|from|the|a|an|in|to|for|on|of|as|at|with|by|from|into|onto|and|or|add|new|my)\b/g, '').trim();
      normalized = normalized.replace(/\s{2,}/g, ' ').trim();
      for (const cat of categories) {
        if (normalized === cat.toLowerCase()) return cat;
        if (normalized.includes(cat.toLowerCase())) return cat;
      }
      return null;
    }

    function extractTaskText(input, category) {
      if (!category) return input.trim();
      const regex = new RegExp(`\\b${category}\\b[\\.\\!\\?\\s]*$`, 'i');
      return input.replace(regex, '').trim();
    }

    function playBeep(frequency = 1500, duration = 120) {
      try {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = ctx.createOscillator();
        const gain = ctx.createGain();
        oscillator.type = 'sine';
        oscillator.frequency.value = frequency;
        oscillator.connect(gain);
        gain.connect(ctx.destination);
        oscillator.start();
        gain.gain.setValueAtTime(1, ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0, ctx.currentTime + duration / 1000);
        oscillator.stop(ctx.currentTime + duration / 1000);
        oscillator.onended = () => ctx.close();
      } catch (e) {}
    }

    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

    function cleanupAudio() {
      if (audioContext) {
        audioContext.close();
        audioContext = null;
      }
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
        stream = null;
      }
      if (silenceTimeout) {
        clearTimeout(silenceTimeout);
        silenceTimeout = null;
      }
    }

    function unlockTTS() {
      return new Promise(resolve => {
        if (ttsUnlocked) return resolve();
        let utter = new SpeechSynthesisUtterance(" ");
        utter.onend = () => { ttsUnlocked = true; resolve(); };
        utter.onerror = () => { ttsUnlocked = true; resolve(); };
        window.speechSynthesis.speak(utter);
      });
    }

    // ---------- Start the App ----------
    loadTasks();
  </script>
</body>
</html>
