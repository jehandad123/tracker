<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Hands-Free Task Manager</title>
  <script src="https://cdn.jsdelivr.net/npm/chrono-node@2.3.4/dist/chrono.min.js"></script>
  <style>
    body { font-family: sans-serif; padding: 20px; max-width: 800px; margin: auto; background: #fefefe; }
    h2 { margin-bottom: 10px; }
    button { margin: 6px 6px 6px 0; padding: 10px 16px; font-size: 16px; cursor: pointer; }
    input[type="text"] { width: 80%; padding: 8px; font-size: 16px; }
    .task-row { margin-bottom: 5px; display: flex; align-items: center; }
    .task-number { font-weight: bold; width: 32px; }
    .category h3 { margin-top: 20px; }
    ul { margin-top: 0; padding-left: 20px; }
    #transcript, #gptAnswer { padding: 10px; margin: 12px 0; border: 1px solid #ccc; border-radius: 5px; }
    #gptAnswer { background: #f9f9f9; }
    .date-badge {
      background: #dfdfdf;
      border-radius: 4px;
      padding: 2px 6px;
      font-size: 12px;
      margin-left: 8px;
      color: #444;
    }
  </style>
</head>
<body>
  <h2>üéôÔ∏è Hands-Free Task Manager</h2>

  <div>
    <input type="text" id="openaiKey" placeholder="OpenAI API Key" />
    <input type="text" id="assemblyKey" placeholder="AssemblyAI API Key" />
    <button id="saveKeysBtn">Save Keys</button>
    <span id="keySaved" style="color:green;display:none;margin-left:10px;">‚úîÔ∏è Saved</span>
  </div>

  <div style="margin-top: 16px;">
    <input type="text" id="manualInput" placeholder="e.g. Buy dog food Home" />
    <button id="addManualBtn">Add Task</button>
  </div>

  <div style="margin-top: 16px;">
    <button id="speakBtn">üé§ Speak</button>
    <button id="handsFreeBtn">ü§ñ Hands Free</button>
    <button id="stopBtn" style="display:none;">‚èπÔ∏è Stop</button>
  </div>

  <div id="transcript"></div>
  <div id="gptAnswer"></div>

  <div id="categories">
    <div class="category" id="Home"><h3>üè† Home</h3><ul></ul></div>
    <div class="category" id="Today"><h3>üìÖ Today</h3><ul></ul></div>
    <div class="category" id="Urgent"><h3>‚ö†Ô∏è Urgent</h3><ul></ul></div>
    <div class="category" id="Shop"><h3>üõí Shop</h3><ul></ul></div>
  </div>

  <h4>üóÇÔ∏è Backup & Restore</h4>
  <button id="exportTasksBtn">Export</button>
  <button id="importTasksBtn">Import</button><br/>
  <textarea id="backupArea" rows="4" cols="70" placeholder="Paste backup JSON here..."></textarea>

  <script>
    const categories = ["Home", "Today", "Urgent", "Shop"];
    // --------- Task Storage, Render, & TTS ---------
    function saveTasks(category, tasks) {
      localStorage.setItem(category, JSON.stringify(tasks));
    }
    function loadTasks() {
      categories.forEach(cat => {
        const ul = document.querySelector(`#${cat} ul`);
        ul.innerHTML = '';
        const tasks = JSON.parse(localStorage.getItem(cat)) || [];
        tasks.forEach((task, idx) => {
          const li = document.createElement("li");
          li.style.listStyleType = "none";
          const row = document.createElement("div");
          row.className = "task-row";
          const num = document.createElement("span");
          num.className = "task-number";
          num.textContent = (idx + 1) + ".";
          row.appendChild(num);
          const txt = document.createElement("span");
          txt.className = "task-text";
          txt.textContent = task.text;
          row.appendChild(txt);
          if (task.date) {
            const badge = document.createElement("span");
            badge.className = "date-badge";
            badge.textContent = new Date(task.date).toLocaleDateString();
            row.appendChild(badge);
          }
          li.appendChild(row);
          ul.appendChild(li);
        });
      });
    }
    function preprocessInput(input) {
      return input.replace(/[\.\,\!\?\;\:]+/g, ' ').replace(/\s+/g, ' ').trim();
    }
    function extractCategory(word) {
      if (!word) return null;
      word = word.toLowerCase();
      return categories.find(cat => word === cat.toLowerCase() || word.includes(cat.toLowerCase()));
    }
    function addTaskInput(inputText) {
      if (handleSpecialCommands(inputText)) return;
      const cleaned = preprocessInput(inputText);
      const words = cleaned.split(" ").filter(Boolean);
      const last = words[words.length - 1];
      const category = extractCategory(last);
      if (!category) return alert("Category not found at the end.");
      const taskText = words.slice(0, -1).join(" ");
      if (!taskText) return alert("Task description is empty.");
      const date = chrono.parseDate(taskText);
      const obj = { text: taskText, date: (date ? date.toISOString() : null) };
      const tasks = JSON.parse(localStorage.getItem(category)) || [];
      tasks.push(obj);
      saveTasks(category, tasks);
      loadTasks();
      speakTextWithWebSpeech("Task added to " + category);
    }

    // --------- Samantha Voice-Only TTS ---------
    function speakTextWithWebSpeech(text) {
      return new Promise((resolve) => {
        const synth = window.speechSynthesis;
        const speak = () => {
          const utter = new SpeechSynthesisUtterance(text);
          const samantha = synth.getVoices().find(v => v.name && v.name.toLowerCase().includes("samantha"));
          utter.voice = samantha || synth.getVoices()[0];
          utter.onend = resolve;
          utter.onerror = resolve;
          synth.speak(utter);
        };
        if (synth.getVoices().length === 0) {
          synth.onvoiceschanged = speak;
        } else {
          speak();
        }
      });
    }

    // --------- Edit/Delete Commands ---------
    function handleSpecialCommands(inputText) {
      // Delete: "Delete task 2 from Home"
      let m = inputText.match(/delete\s+task\s+(\d+)\s+from\s+(\w+)/i);
      if (m) {
        const idx = parseInt(m[1], 10) - 1;
        const cat = extractCategory(m[2]);
        if (!cat) return alert("No category.");
        const tasks = JSON.parse(localStorage.getItem(cat)) || [];
        if (idx < 0 || idx >= tasks.length) return alert("Invalid task number for " + cat);
        tasks.splice(idx, 1);
        saveTasks(cat, tasks);
        loadTasks();
        speakTextWithWebSpeech("Task deleted from " + cat);
        return true;
      }
      // Edit: "Edit task 2 Home to New task Home"
      m = inputText.match(/edit\s+task\s+(\d+)\s+(\w+)\s+to\s+(.+)/i);
      if (m) {
        const idx = parseInt(m[1],10) - 1;
        const cat = extractCategory(m[2]);
        const newText = m[3].trim();
        if (!cat || !newText) return alert("Invalid edit command.");
        const tasks = JSON.parse(localStorage.getItem(cat)) || [];
        if (idx < 0 || idx >= tasks.length) return alert("Invalid task number for " + cat);
        let parsedDate = chrono.parseDate(newText);
        tasks[idx] = { text: newText, date: parsedDate ? parsedDate.toISOString() : null };
        saveTasks(cat, tasks);
        loadTasks();
        speakTextWithWebSpeech("Task updated in " + cat);
        return true;
      }
      return false;
    }

    // --------- Manual Buttons, Export/Import, Key Save ---------
    document.getElementById("addManualBtn").onclick = () => {
      const text = document.getElementById("manualInput").value.trim();
      if (text) {
        addTaskInput(text);
        document.getElementById("manualInput").value = "";
      }
    };
    document.getElementById("exportTasksBtn").onclick = function() {
      const backup = {};
      categories.forEach(cat => {
        backup[cat] = JSON.parse(localStorage.getItem(cat)) || [];
      });
      document.getElementById("backupArea").value = JSON.stringify(backup, null, 2);
    };
    document.getElementById("importTasksBtn").onclick = function() {
      try {
        const backup = JSON.parse(document.getElementById("backupArea").value);
        Object.entries(backup).forEach(([cat, tasks]) => {
          if (categories.includes(cat)) {
            localStorage.setItem(cat, JSON.stringify(tasks));
          }
        });
        loadTasks();
        alert("Tasks restored!");
      } catch (e) {
        alert("Invalid backup JSON.");
      }
    };
    document.getElementById("saveKeysBtn").onclick = () => {
      localStorage.setItem("openai_api_key", document.getElementById("openaiKey").value);
      localStorage.setItem("assembly_api_key", document.getElementById("assemblyKey").value);
      document.getElementById("keySaved").style.display = "inline";
      setTimeout(() => document.getElementById("keySaved").style.display = "none", 1500);
    };
    document.getElementById("openaiKey").value = localStorage.getItem("openai_api_key") || "";
    document.getElementById("assemblyKey").value = localStorage.getItem("assembly_api_key") || "";

    loadTasks();
    // --------- Speech Recognition & Hands-Free Fixes ---------
    let recognizing = false;
    let stopConversationFlag = false;

    const transcriptDiv = document.getElementById('transcript');
    const gptAnswerDiv = document.getElementById('gptAnswer');
    const speakBtn = document.getElementById('speakBtn');
    const handsFreeBtn = document.getElementById('handsFreeBtn');
    const stopBtn = document.getElementById('stopBtn');

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    function unlockTTS() {
      return new Promise(resolve => {
        if (window.speechSynthesis.getVoices().length) return resolve();
        let utter = new SpeechSynthesisUtterance('');
        utter.onend = resolve;
        speechSynthesis.speak(utter);
      });
    }

    async function captureVoice() {
      return new Promise((resolve) => {
        if (!(window.SpeechRecognition || window.webkitSpeechRecognition)) {
          alert('Your browser does not support Speech Recognition');
          resolve('');
          return;
        }
        const Recognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        const recognition = new Recognition();
        recognition.lang = 'en-US';
        recognition.interimResults = false;
        recognition.maxAlternatives = 1;

        transcriptDiv.textContent = 'Listening...';

        let timedOut = false;
        const timeout = setTimeout(() => {
          timedOut = true;
          recognition.stop();
          transcriptDiv.textContent = 'No input detected (timeout)';
          resolve('');
        }, 20000); // 20s timeout

        recognition.onresult = event => {
          clearTimeout(timeout);
          if (timedOut) return;
          const text = event.results[0][0].transcript.trim();
          transcriptDiv.textContent = 'You said: ' + text;
          resolve(text);
        };

        recognition.onerror = event => {
          clearTimeout(timeout);
          transcriptDiv.textContent = 'Speech error: ' + event.error;
          resolve('');
        };

        recognition.onend = () => {
          if (!timedOut) clearTimeout(timeout);
        };

        recognition.start();
      });
    }

    async function startSpeakOnce() {
      if (recognizing) return;
      recognizing = true;
      const transcript = await captureVoice();
      recognizing = false;
      if (transcript) {
        addTaskInput(transcript);
      }
    }

    async function handsFreeLoop() {
      if (recognizing) return;
      recognizing = true;
      stopConversationFlag = false;
      stopBtn.style.display = 'inline';

      while (!stopConversationFlag) {
        transcriptDiv.textContent = 'Listening...';
        const text = await captureVoice();

        if (!text) {
          await sleep(500);
          continue;
        }

        if (/^(stop|cancel|exit|goodbye|disconnect)$/i.test(text)) {
          speakTextWithWebSpeech('Conversation ended.');
          break;
        }

        addTaskInput(text);
        await sleep(400);
      }

      stopBtn.style.display = 'none';
      recognizing = false;
    }

    speakBtn.onclick = () => startSpeakOnce();
    handsFreeBtn.onclick = () => {
      if (recognizing) return;
      handsFreeLoop();
    };
    stopBtn.onclick = () => {
      stopConversationFlag = true;
    };
    // --------- EXTENSION PLACEHOLDER: GPT & AssemblyAI Integration ---------
    // If you want to (re)integrate OpenAI GPT or AssemblyAI functions, 
    // add their functions right here, keeping their UI references (e.g., gptAnswerDiv)
    // Example:
    // async function askGpt(userText) { ... }

    // You still have #openaiKey, #assemblyKey elements and can reuse:
    // localStorage.getItem("openai_api_key")
    // localStorage.getItem("assembly_api_key")

    // If you need GPT replies to show, set gptAnswerDiv.textContent = ___;

    // For advanced voice-to-text via AssemblyAI, add network code here in the same format
    // as your original file.

    // Everything else (category buttons, backup/import, etc.) remains as above.
  </script>
</body>
</html>
